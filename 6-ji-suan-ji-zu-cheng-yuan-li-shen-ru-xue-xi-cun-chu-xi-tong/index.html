<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>6、计算机组成原理: 深入学习存储系统 | Lvjia</title><meta name="author" content="lvting.chi"><meta name="copyright" content="lvting.chi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="计算机组成原理存储系统全解析一、存储系统基础认知1.1 存储系统的核心地位存储系统是计算机的重要组成部分，它负责数据和程序的存储与访问。从计算机的工作原理来看，CPU 执行指令时，需要从存储器中获取指令和操作数，执行完成后再将结果存储回存储器。一个高效的存储系统，能够极大地提升计算机的整体性能。 1.2 存储系统的层次架构为平衡存储容量、访问速度与成本，现代计算机采用层次化存储结构，从高速到低速、">
<meta property="og:type" content="article">
<meta property="og:title" content="6、计算机组成原理: 深入学习存储系统">
<meta property="og:url" content="http://lvjia.netlify.app/6-ji-suan-ji-zu-cheng-yuan-li-shen-ru-xue-xi-cun-chu-xi-tong/index.html">
<meta property="og:site_name" content="Lvjia">
<meta property="og:description" content="计算机组成原理存储系统全解析一、存储系统基础认知1.1 存储系统的核心地位存储系统是计算机的重要组成部分，它负责数据和程序的存储与访问。从计算机的工作原理来看，CPU 执行指令时，需要从存储器中获取指令和操作数，执行完成后再将结果存储回存储器。一个高效的存储系统，能够极大地提升计算机的整体性能。 1.2 存储系统的层次架构为平衡存储容量、访问速度与成本，现代计算机采用层次化存储结构，从高速到低速、">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://lvjia.netlify.app/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-09-04T13:40:00.000Z">
<meta property="article:modified_time" content="2025-09-21T13:52:33.394Z">
<meta property="article:author" content="lvting.chi">
<meta property="article:tag" content="基础知识">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://lvjia.netlify.app/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "6、计算机组成原理: 深入学习存储系统",
  "url": "http://lvjia.netlify.app/6-ji-suan-ji-zu-cheng-yuan-li-shen-ru-xue-xi-cun-chu-xi-tong/",
  "image": "http://lvjia.netlify.app/img/butterfly-icon.png",
  "datePublished": "2025-09-04T13:40:00.000Z",
  "dateModified": "2025-09-21T13:52:33.394Z",
  "author": [
    {
      "@type": "Person",
      "name": "lvting.chi",
      "url": "http://lvjia.netlify.app"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://lvjia.netlify.app/6-ji-suan-ji-zu-cheng-yuan-li-shen-ru-xue-xi-cun-chu-xi-tong/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '6、计算机组成原理: 深入学习存储系统',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Lvjia" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Lvjia</span></a><a class="nav-page-title" href="/"><span class="site-name">6、计算机组成原理: 深入学习存储系统</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">6、计算机组成原理: 深入学习存储系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-04T13:40:00.000Z" title="发表于 2025-09-04 21:40:00">2025-09-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-21T13:52:33.394Z" title="更新于 2025-09-21 21:52:33">2025-09-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="计算机组成原理存储系统全解析"><a href="#计算机组成原理存储系统全解析" class="headerlink" title="计算机组成原理存储系统全解析"></a>计算机组成原理存储系统全解析</h1><h2 id="一、存储系统基础认知"><a href="#一、存储系统基础认知" class="headerlink" title="一、存储系统基础认知"></a>一、存储系统基础认知</h2><h3 id="1-1-存储系统的核心地位"><a href="#1-1-存储系统的核心地位" class="headerlink" title="1.1 存储系统的核心地位"></a>1.1 存储系统的核心地位</h3><p>存储系统是计算机的重要组成部分，它负责数据和程序的存储与访问。从计算机的工作原理来看，CPU 执行指令时，需要从存储器中获取指令和操作数，执行完成后再将结果存储回存储器。一个高效的存储系统，能够极大地提升计算机的整体性能。</p>
<h3 id="1-2-存储系统的层次架构"><a href="#1-2-存储系统的层次架构" class="headerlink" title="1.2 存储系统的层次架构"></a>1.2 存储系统的层次架构</h3><p>为平衡<strong>存储容量</strong>、<strong>访问速度</strong>与<strong>成本</strong>，现代计算机采用层次化存储结构，从高速到低速、从贵到便宜依次为：</p>
<ul>
<li><strong>寄存器</strong>：位于 CPU 内部，速度极快，但容量极小（通常以字节甚至位计），用于暂存 CPU 正在处理的少量数据。比如 CPU 进行加法运算时，两个操作数会先暂存在寄存器中。</li>
<li><strong>高速缓冲存储器（Cache）</strong>：介于 CPU 与主存之间，是高速小容量存储器。它缓解了 CPU 与主存的速度差异。当 CPU 要访问主存数据时，先查 Cache，命中则直接读取；缺失则从主存读，并将数据块调入 Cache，方便后续访问。就像我们常用的工具放在手边抽屉（Cache），不用每次都去仓库（主存）找。</li>
<li><strong>主存储器（内存）</strong>：计算机的主要内存，存储当前运行的程序与数据，CPU 可直接访问。它是存储系统的核心交互层。</li>
<li><strong>辅助存储器（外存）</strong>：如硬盘、光盘、U 盘等，容量大、成本低但访问速度慢，用于长期存储数据，需用时调入主存供 CPU 使用。好比仓库，存储大量货物，用时再搬运到车间（主存）。</li>
</ul>
<h3 id="1-3-存储系统性能指标"><a href="#1-3-存储系统性能指标" class="headerlink" title="1.3 存储系统性能指标"></a>1.3 存储系统性能指标</h3><ul>
<li><p><strong>存储容量</strong>：存储器能存储的二进制信息总量，单位有字节（Byte）、千字节（KB，(2<sup>10</sup>) Byte）、兆字节（MB，(2<sup>20</sup>) Byte）、吉字节（GB，(2<sup>30</sup>) Byte）、太字节（TB，(2<sup>40</sup>) Byte）等。</p>
</li>
<li><p>存储速度：</p>
<ul>
<li><strong>存取时间</strong>：从存储器接收到读 / 写命令到完成操作的时间。</li>
<li><strong>存取周期</strong>：两次连续读 / 写操作的最小时间间隔，通常略大于存取时间。比如主存存取周期可能是几十纳秒，而 Cache 存取周期仅几纳秒。</li>
</ul>
</li>
<li><p><strong>带宽</strong>：单位时间内存储器传输的数据量，体现数据传输能力。像高速公路的车道数，车道越多（带宽越大），单位时间能通过的车辆（数据）就越多。</p>
</li>
</ul>
<h2 id="二、主存储器深度剖析"><a href="#二、主存储器深度剖析" class="headerlink" title="二、主存储器深度剖析"></a>二、主存储器深度剖析</h2><p>主存是存储系统的核心，CPU 对其访问最为频繁。</p>
<h3 id="2-1-主存的硬件组成"><a href="#2-1-主存的硬件组成" class="headerlink" title="2.1 主存的硬件组成"></a>2.1 主存的硬件组成</h3><p>主存通常由<strong>存储体</strong>、<strong>地址寄存器（MAR）</strong>、<strong>地址译码器</strong>、<strong>数据寄存器（MDR）</strong>、<strong>读写控制电路</strong>等组成，各部分协同工作：</p>
<ul>
<li><strong>存储体</strong>：存储单元的集合，每个存储单元有唯一地址。可类比为一个个带编号的储物格，每个格子存数据。</li>
<li><strong>地址寄存器（MAR）</strong>：存放 CPU 要访问的存储单元地址。比如要找 “储物格 101”，MAR 就存 “101”。</li>
<li><strong>地址译码器</strong>：根据 MAR 中的地址，选中对应存储单元。如同根据 “101”，打开第 101 号储物格的锁。</li>
<li><strong>数据寄存器（MDR）</strong>：暂存要写入存储体或从存储体读出的数据。往储物格放东西（写）或取东西（读）时，先放 MDR 暂存。</li>
<li><strong>读写控制电路</strong>：根据 CPU 发出的读 / 写命令，控制数据的读写操作。决定是往储物格放东西，还是从里面取东西。</li>
</ul>
<p>用字符图展示主存组成逻辑：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">CPU &lt;-&gt; MAR &lt;-&gt; 地址译码器 &lt;-&gt; 存储体</span><br><span class="line">        ^                        ^</span><br><span class="line">        |                        |</span><br><span class="line">        MDR &lt;------------------ 读写控制电路</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-2-存储单元与地址编码"><a href="#2-2-存储单元与地址编码" class="headerlink" title="2.2 存储单元与地址编码"></a>2.2 存储单元与地址编码</h3><p>存储单元是主存中最小的可寻址单位，通常一个存储单元存 1 字节（8 位）数据。为区分不同存储单元，需为每个单元分配唯一地址，地址以二进制编码。</p>
<p>例如，容量为 (2<sup>n</sup>) 字节的主存，地址需 n 位二进制数，地址范围从 0 到 (2<sup>n-1</sup>)。若主存容量为 1MB（2<sup>20</sup>) 字节），则地址需 20 位，可表示 0 到 (2<sup>20</sup> - 1) 共 1048576 个存储单元。</p>
<h3 id="2-3-主存的技术指标细化"><a href="#2-3-主存的技术指标细化" class="headerlink" title="2.3 主存的技术指标细化"></a>2.3 主存的技术指标细化</h3><ul>
<li><strong>存储容量</strong>：除了总容量，还需关注<strong>位宽</strong>，即每个存储单元能存储的二进制位数，常见的有 8 位（1 字节）、16 位、32 位等。</li>
<li><strong>存取速度</strong>：不同类型主存（如 DRAM、SRAM）存取速度差异大。SRAM 存取速度快，但集成度低；DRAM 存取速度稍慢，但集成度高、成本低。</li>
<li><strong>功耗与成本</strong>：功耗影响设备的散热与续航（如移动设备），成本则关系到整机的价格。需在性能、功耗、成本间权衡，比如服务器主存更看重性能，移动设备主存更看重低功耗与小体积。</li>
</ul>
<h2 id="三、随机存取存储器（RAM）详解"><a href="#三、随机存取存储器（RAM）详解" class="headerlink" title="三、随机存取存储器（RAM）详解"></a>三、随机存取存储器（RAM）详解</h2><p>RAM 可随机对各存储单元读 / 写，依存储原理分为<strong>静态 RAM（SRAM）与动态 RAM（DRAM）</strong>。</p>
<h3 id="3-1-静态-RAM（SRAM）"><a href="#3-1-静态-RAM（SRAM）" class="headerlink" title="3.1 静态 RAM（SRAM）"></a>3.1 静态 RAM（SRAM）</h3><h4 id="3-1-1-存储原理"><a href="#3-1-1-存储原理" class="headerlink" title="3.1.1 存储原理"></a>3.1.1 存储原理</h4><p>SRAM 利用<strong>触发器的双稳态</strong>存储信息，触发器的两个稳定状态分别表示 “0” 和 “1”。只要电源不断，信息就可长期保持。</p>
<p>一个基本 SRAM 存储单元通常由 6 个 MOS 管组成双稳态触发器，结构示意（简化）：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">+---+     +---+</span><br><span class="line">| T1|-----| T2|</span><br><span class="line">+---+     +---+</span><br><span class="line">  |         |</span><br><span class="line">+---+     +---+</span><br><span class="line">| T3|-----| T4|</span><br><span class="line">+---+     +---+</span><br><span class="line">  |         |</span><br><span class="line">+---+     +---+</span><br><span class="line">| T5|     | T6|</span><br><span class="line">+---+     +---+</span><br></pre></td></tr></tbody></table></figure>

<p>T1 - T4 构成双稳态触发器，T5、T6 为行选通管，控制该单元与位线的连接。</p>
<h4 id="3-1-2-特点与应用"><a href="#3-1-2-特点与应用" class="headerlink" title="3.1.2 特点与应用"></a>3.1.2 特点与应用</h4><ul>
<li><strong>优点</strong>：存取速度快（纳秒级），无需刷新，因电源供电时触发器状态稳定。</li>
<li><strong>缺点</strong>：集成度低（相同面积芯片，存储单元少）、功耗大（触发器需持续供电维持状态）、成本高。</li>
<li><strong>应用</strong>：因速度快，常用于 <strong>Cache 存储器</strong>，拉近 CPU 与主存的速度差距。</li>
</ul>
<h3 id="3-2-动态-RAM（DRAM）"><a href="#3-2-动态-RAM（DRAM）" class="headerlink" title="3.2 动态 RAM（DRAM）"></a>3.2 动态 RAM（DRAM）</h3><h4 id="3-2-1-存储原理"><a href="#3-2-1-存储原理" class="headerlink" title="3.2.1 存储原理"></a>3.2.1 存储原理</h4><p>DRAM 利用<strong>电容存储电荷</strong>的原理存储信息：电容充满电表示 “1”，放电后表示 “0”。</p>
<p>但电容存在漏电，电荷会逐渐泄漏，导致信息丢失。因此，DRAM 需<strong>定期刷新</strong>，补充电容电荷以保持信息正确。</p>
<p>DRAM 存储单元通常由 1 个 MOS 管和 1 个电容组成（简化结构）：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">+---+</span><br><span class="line">| T |---- 位线</span><br><span class="line">+---+</span><br><span class="line">  |</span><br><span class="line">+---+</span><br><span class="line">| C |---- 电容（存储电荷）</span><br><span class="line">+---+</span><br></pre></td></tr></tbody></table></figure>

<p>T 为选通管，控制电容与位线的连接；C 为存储电容。</p>
<h4 id="3-2-2-刷新方式"><a href="#3-2-2-刷新方式" class="headerlink" title="3.2.2 刷新方式"></a>3.2.2 刷新方式</h4><p>为解决电容漏电问题，DRAM 有三种刷新方式：</p>
<ul>
<li><strong>集中刷新</strong>：在一个刷新周期内，集中一段时间对整个存储器刷新，此时存储器无法正常读 / 写，出现 “死区”。</li>
</ul>
<p>示例：假设存储器存取周期为 T，刷新周期为 2ms，每个存储单元刷新时间为 t，存储单元数为 n，则 “死区” 时间为 n × t。若 n = 1024，t = 0.1μs，则死区时间为 1024 × 0.1μs = 102.4μs，占刷新周期（2ms = 2000μs）的约 5.12%。</p>
<ul>
<li><strong>分散刷新</strong>：将刷新操作分散到每个存取周期，每个周期分为读 / 写时间和刷新时间。这样存储器存取周期变长，但无 “死区”。</li>
</ul>
<p>示例：原存取周期为 T，刷新时间为 t，则新存取周期为 T + t。若 T = 100ns，t = 20ns，则新周期为 120ns，存取速度下降，但无访问中断。</p>
<ul>
<li><strong>异步刷新</strong>：结合集中与分散刷新的优点。将刷新周期 2ms 分成 n 段（n 为行数），每段时间为 2ms / n，每段时间内对一行刷新。</li>
</ul>
<p>示例：若存储器有 1024 行，刷新周期 2ms，则每 2ms / 1024 ≈ 1.95μs 刷新一行。这样 “死区” 时间仅为一行的刷新时间（如 0.1μs），远小于集中刷新，且存取周期无需大幅延长。</p>
<h4 id="3-2-3-特点与应用"><a href="#3-2-3-特点与应用" class="headerlink" title="3.2.3 特点与应用"></a>3.2.3 特点与应用</h4><ul>
<li><strong>优点</strong>：集成度高（相同面积芯片，存储单元多）、功耗低（仅刷新时消耗能量）、成本低。</li>
<li><strong>缺点</strong>：存取速度比 SRAM 慢（百纳秒级），需刷新操作。</li>
<li><strong>应用</strong>：因容量大、成本低，常用于<strong>主存储器</strong>，满足计算机对内存容量的需求。</li>
</ul>
<h3 id="3-3-SRAM-与-DRAM-全面对比"><a href="#3-3-SRAM-与-DRAM-全面对比" class="headerlink" title="3.3 SRAM 与 DRAM 全面对比"></a>3.3 SRAM 与 DRAM 全面对比</h3><table>
<thead>
<tr>
<th>特性</th>
<th>SRAM</th>
<th>DRAM</th>
</tr>
</thead>
<tbody><tr>
<td>存储原理</td>
<td>触发器（双稳态）</td>
<td>电容存储电荷</td>
</tr>
<tr>
<td>存取速度</td>
<td>快（纳秒级，如 5 - 20ns）</td>
<td>慢（百纳秒级，如 50 - 100ns）</td>
</tr>
<tr>
<td>集成度</td>
<td>低（相同工艺下，存储单元少）</td>
<td>高（相同工艺下，存储单元多）</td>
</tr>
<tr>
<td>功耗</td>
<td>大（触发器需持续供电）</td>
<td>小（仅刷新时耗电）</td>
</tr>
<tr>
<td>成本</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>刷新需求</td>
<td>不需要</td>
<td>需要</td>
</tr>
<tr>
<td>主要应用</td>
<td>Cache</td>
<td>主存</td>
</tr>
</tbody></table>
<h2 id="四、只读存储器（ROM）解析"><a href="#四、只读存储器（ROM）解析" class="headerlink" title="四、只读存储器（ROM）解析"></a>四、只读存储器（ROM）解析</h2><p>ROM 是只能读出、不能随意写入的存储器，信息一旦写入可长期保存，断电不丢失，用于存储固定程序与数据（如计算机 BIOS 程序）。</p>
<h3 id="4-1-掩模-ROM"><a href="#4-1-掩模-ROM" class="headerlink" title="4.1 掩模 ROM"></a>4.1 掩模 ROM</h3><p>掩模 ROM 的信息在芯片制造时由厂家通过<strong>掩模工艺</strong>写入，用户无法修改。适合大批量生产、程序固定的产品（如早期游戏机卡带中的程序），成本低，但灵活性差 —— 程序错误则芯片报废。</p>
<h3 id="4-2-可编程-ROM（PROM）"><a href="#4-2-可编程-ROM（PROM）" class="headerlink" title="4.2 可编程 ROM（PROM）"></a>4.2 可编程 ROM（PROM）</h3><p>PROM 允许用户<strong>一次性写入</strong>信息，写入后不可修改。用户用专门编程器写入程序，但写入错误则芯片报废。就像 “一次性刻录光盘”，刻错就无法再用。</p>
<h3 id="4-3-可擦除可编程-ROM（EPROM）"><a href="#4-3-可擦除可编程-ROM（EPROM）" class="headerlink" title="4.3 可擦除可编程 ROM（EPROM）"></a>4.3 可擦除可编程 ROM（EPROM）</h3><p>EPROM 可<strong>多次擦除和写入</strong>，存储单元为浮栅晶体管：写入时加高压将电荷注入浮栅；擦除时用<strong>紫外线照射</strong>浮栅，使电荷泄漏，清除信息。</p>
<p>EPROM 芯片上方有<strong>石英窗口</strong>，用于紫外线照射擦除。擦除后可再次写入新信息，灵活性比 PROM 强，但擦除需专用设备且耗时（通常需几分钟）。</p>
<h3 id="4-4-电可擦除可编程-ROM（EEPROM）"><a href="#4-4-电可擦除可编程-ROM（EEPROM）" class="headerlink" title="4.4 电可擦除可编程 ROM（EEPROM）"></a>4.4 电可擦除可编程 ROM（EEPROM）</h3><p>EEPROM 用电信号<strong>擦除和写入</strong>，无需紫外线，使用更方便。可在<strong>字节级</strong>擦除和写入（EPROM 通常需整体擦除），擦写速度快（毫秒级），但成本比 EPROM 高。常用于需要频繁修改少量数据的场景（如存储设备的配置信息）。</p>
<h3 id="4-5-Flash-Memory（闪存）"><a href="#4-5-Flash-Memory（闪存）" class="headerlink" title="4.5 Flash Memory（闪存）"></a>4.5 Flash Memory（闪存）</h3><p>Flash Memory 是<strong>非易失性存储器</strong>，结合 EPROM 与 EEPROM 的优点：可快速批量擦除和写入，存储容量大、成本低。</p>
<p>它的存储单元结构与 EEPROM 类似，但擦除时是按 “块” 操作（而非字节），写入前需先擦除块。广泛应用于 U 盘、固态硬盘（SSD）、手机存储等领域，是当前消费级存储的主流技术之一。</p>
<h2 id="五、存储器与-CPU-的连接技术"><a href="#五、存储器与-CPU-的连接技术" class="headerlink" title="五、存储器与 CPU 的连接技术"></a>五、存储器与 CPU 的连接技术</h2><p>存储器与 CPU 通过<strong>地址总线</strong>、<strong>数据总线</strong>、<strong>控制总线</strong>连接，实现数据传输与命令传递。</p>
<h3 id="5-1-总线的作用与分类"><a href="#5-1-总线的作用与分类" class="headerlink" title="5.1 总线的作用与分类"></a>5.1 总线的作用与分类</h3><ul>
<li><strong>地址总线（AB）</strong>：传输 CPU 要访问的存储器单元地址，位数决定 CPU 可直接寻址的存储器空间大小。如地址总线为 n 位，可寻址空间为2<sup>n</sup>字节。</li>
<li><strong>数据总线（DB）</strong>：传输 CPU 与存储器之间的数据，位数通常与 CPU 字长相同，决定每次数据传输的位数。如 32 位 CPU，数据总线通常为 32 位，一次可传 4 字节。</li>
<li><strong>控制总线（CB）</strong>：传输 CPU 对存储器的控制命令（如读命令 RD、写命令 WR）及存储器对 CPU 的状态反馈信号（如准备好信号 Ready）。</li>
</ul>
<h3 id="5-2-存储器容量扩展"><a href="#5-2-存储器容量扩展" class="headerlink" title="5.2 存储器容量扩展"></a>5.2 存储器容量扩展</h3><p>当单个存储芯片容量不足时，需进行<strong>位扩展</strong>、<strong>字扩展</strong>或<strong>字位同时扩展</strong>。</p>
<h4 id="5-2-1-位扩展"><a href="#5-2-1-位扩展" class="headerlink" title="5.2.1 位扩展"></a>5.2.1 位扩展</h4><p>位扩展用于<strong>增加存储器的位数（数据宽度）</strong>。如用 2 片 (1K x 4) 位的存储芯片组成 (1K x 8) 位的存储器。</p>
<p><strong>连接方法</strong>：各存储芯片的<strong>地址线</strong>、<strong>片选线<span style="text-decoration: overline;">CS</span>、读 / 写控制线<span style="text-decoration: overline;">WE</span></strong> 分别并联，<strong>数据线</strong>分别引出，组成更宽的总线。</p>
<p>用字符图示意位扩展（2 片 (1K x 4) 位 → (1K x 8) 位）：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">          +-----------------+        +-----------------+</span><br><span class="line">地址线A0~A9|                 |        |                 |</span><br><span class="line">---------&gt;| 芯片1（1K×4位） |        | 芯片2（1K×4位） |&lt;---------地址线A0~A9</span><br><span class="line">          |                 |        |                 |</span><br><span class="line">片选线CS  |                 |        |                 |&lt;---------片选线CS</span><br><span class="line">---------&gt;|                 |        |                 |</span><br><span class="line">读/写线WE |                 |        |                 |&lt;---------读/写线WE</span><br><span class="line">---------&gt;|                 |        |                 |</span><br><span class="line">          | 数据线D0~D3     |        | 数据线D4~D7     |</span><br><span class="line">          +-----------------+        +-----------------+</span><br><span class="line">                 |                        |</span><br><span class="line">                 +------------------------+</span><br><span class="line">                          |</span><br><span class="line">                   数据线D0~D7（8位）</span><br></pre></td></tr></tbody></table></figure>

<h4 id="5-2-2-字扩展"><a href="#5-2-2-字扩展" class="headerlink" title="5.2.2 字扩展"></a>5.2.2 字扩展</h4><p>字扩展用于<strong>增加存储器的字数（存储单元数量）</strong>。如用 2 片 (1K x 8) 位的存储芯片组成 (2K x 8) 位的存储器。</p>
<p><strong>连接方法</strong>：各存储芯片的<strong>地址线</strong>、<strong>数据线</strong>、<strong>读 / 写控制线</strong>分别并联，<strong>片选线</strong>由地址译码器的不同输出端控制，以选择不同芯片。</p>
<p>用字符图示意字扩展（2 片 (1K x 8) 位 → (2K x 8) 位）：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">地址线A0~A9 |        +-----------------+        +-----------------+</span><br><span class="line">------------&gt;|        | 芯片1（1K×8位） |        | 芯片2（1K×8位） |</span><br><span class="line">            |        |                 |        |                 |</span><br><span class="line">地址线A10   |        |                 |        |                 |</span><br><span class="line">------------&gt;| 译码器 |                 |        |                 |</span><br><span class="line">            |        +-----------------+        +-----------------+</span><br><span class="line">            |               |                        |</span><br><span class="line">            |               |&lt;---------数据线D0~D7（8位）</span><br><span class="line">            |               |</span><br><span class="line">            | 片选端CS0      | 片选端CS1</span><br><span class="line">            +---------------+</span><br></pre></td></tr></tbody></table></figure>

<p>当 A<sub>10</sub> = 0 时，译码器输出低电平至芯片 1 的 <span style="text-decoration: overline;">CS</span> 端，芯片 1 被选中；A<sub>10</sub> = 1 时，译码器输出低电平至芯片 2 的 <span style="text-decoration: overline;">CS</span> 端，芯片 2 被选中。通过这种方式，2 片 1K × 8 位芯片的地址空间拼接为 2K × 8 位，地址范围从 00000000000（A<sub>10</sub>A<sub>9</sub>…A<sub>0</sub> = 000…0）到 11111111111（A<sub>10</sub>A<sub>9</sub>…A<sub>0</sub> = 111…1），共 2048 个存储单元。</p>
<h4 id="5-2-3-字位同时扩展"><a href="#5-2-3-字位同时扩展" class="headerlink" title="5.2.3 字位同时扩展"></a>5.2.3 字位同时扩展</h4><p>当既需增加存储器的字数，又需增加位数时，需进行<strong>字位同时扩展</strong>。例如，用 4 片 (1K x 4) 位的存储芯片组成 (2K x 8) 位的存储器。</p>
<p><strong>连接步骤</strong>：</p>
<ol>
<li><strong>位扩展分组</strong>：先将 2 片 (1K x 4) 位芯片进行位扩展，组成 1 组 (1K x 8) 位的 “芯片组”。具体连接为：2 片芯片的地址线、片选线、读 / 写控制线分别并联，数据线分别引出为 (D0 ~ D3) 和 (D4 ~ D7)，合并为 8 位数据线。</li>
<li><strong>字扩展拼接</strong>：再将 2 组 (1K x 8) 位的芯片组进行字扩展。2 组芯片的地址线（(A0 ~ A9)）、数据线（(D0 ~ D7)）、读 / 写控制线分别并联，新增地址线 A10 接入地址译码器，译码器输出 2 路片选信号，分别连接 2 组芯片的片选端。</li>
</ol>
<p>下图示意字位同时扩展（4 片 (1K x 4) 位 → (2K x 8) 位）：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">          第一组（1K×8位）          第二组（1K×8位）</span><br><span class="line">    +-----------------------+    +-----------------------+</span><br><span class="line">    | 芯片1（1K×4位） 芯片2（1K×4位）| 芯片3（1K×4位） 芯片4（1K×4位）|</span><br><span class="line">    |                       |    |                       |</span><br><span class="line">A0~A9 -&gt; 地址线并联         |    | 地址线并联 &lt;- A0~A9    |</span><br><span class="line">    |                       |    |                       |</span><br><span class="line">CS1 -&gt;  片选线并联          |    | 片选线并联 &lt;- CS2      |</span><br><span class="line">    |                       |    |                       |</span><br><span class="line">WE -&gt;   读/写线并联         |    | 读/写线并联 &lt;- WE      |</span><br><span class="line">    |                       |    |                       |</span><br><span class="line">    | D0~D3        D4~D7    |    | D0~D3        D4~D7    |</span><br><span class="line">    +-----------------------+    +-----------------------+</span><br><span class="line">             |                         |</span><br><span class="line">             +-------------------------+</span><br><span class="line">                      |</span><br><span class="line">               D0~D7（8位数据线）</span><br><span class="line">                      |</span><br><span class="line">             地址译码器 &lt;- A10</span><br></pre></td></tr></tbody></table></figure>



<p>当 (A10 = 0) 时，CS1 有效，选中第一组芯片，地址范围为 (00000000000 ~ 01111111111)；当 (A10 = 1) 时，CS2 有效，选中第二组芯片，地址范围为 (10000000000 ~ 11111111111)，最终实现 (2K x 8) 位的存储容量。</p>
<h3 id="5-3-存储芯片的片选控制"><a href="#5-3-存储芯片的片选控制" class="headerlink" title="5.3 存储芯片的片选控制"></a>5.3 存储芯片的片选控制</h3><p>片选控制是存储器与 CPU 连接的关键环节，决定了哪个存储芯片被激活参与数据读写。常见的片选控制方式有<strong>线选法</strong>和<strong>译码法</strong>。</p>
<h4 id="5-3-1-线选法"><a href="#5-3-1-线选法" class="headerlink" title="5.3.1 线选法"></a>5.3.1 线选法</h4><p>线选法直接用 CPU 地址总线的高位地址线作为存储芯片的片选信号。例如，用 2 片 (1K x 8) 位芯片组成 (2K x 8) 位存储器时，可将地址线 A10 直接连接芯片 1 的 (<span style="text-decoration: overline;">CS</span>) 端，A11 直接连接芯片 2 的 (<span style="text-decoration: overline;">CS</span>) 端（假设地址总线宽度足够）。</p>
<p><strong>优点</strong>：电路简单，无需额外译码器。 <strong>缺点</strong>：地址空间不连续，且浪费地址资源。例如，若仅用 A10 和 A11 作为片选信号，当 (A10 = 0) 且 (A11 = 0) 时，无芯片被选中，对应地址空间闲置；当 (A10 = 1) 且 (A11 = 1) 时，两片芯片同时被选中，可能导致数据冲突。因此，线选法仅适用于存储容量小、地址空间要求不高的场景。</p>
<h4 id="5-3-2-译码法"><a href="#5-3-2-译码法" class="headerlink" title="5.3.2 译码法"></a>5.3.2 译码法</h4><p>译码法通过地址译码器将 CPU 地址总线的高位地址线转换为多个片选信号，实现对多片存储芯片的有序选择。根据译码输出信号的数量，可分为<strong>全译码</strong>和<strong>部分译码</strong>。</p>
<ul>
<li><strong>全译码</strong>：将 CPU 地址总线的所有高位地址线（除片内地址线外）都接入译码器，每个译码输出对应唯一的存储芯片或芯片组，地址空间连续且无浪费。例如，用 3-8 译码器（如 74LS138），将 (A12、A11、A10) 作为输入，可输出 8 路片选信号，控制 8 片 (1K x 8) 位芯片，组成 (8K x 8) 位存储器，地址范围连续且无闲置。</li>
<li><strong>部分译码</strong>：仅将 CPU 地址总线的部分高位地址线接入译码器，剩余高位地址线闲置（或接地 / 接高电平）。这种方式会导致 “地址重叠”，即多个不同的地址对应同一个存储单元。例如，若用 A10 接入 2-4 译码器（仅用 1 路输入），控制 2 片 (1K x 8) 位芯片，闲置的 (A11、A12) 无论为 0 或 1，都会选中对应的芯片，导致每片芯片对应多个地址空间。部分译码适用于对地址空间连续性要求不高，但希望简化电路的场景。</li>
</ul>
<h2 id="六、存储器的校验技术"><a href="#六、存储器的校验技术" class="headerlink" title="六、存储器的校验技术"></a>六、存储器的校验技术</h2><p>在计算机运行过程中，存储器中的数据可能因电磁干扰、电源波动、硬件老化等因素出现错误。为保障数据正确性，需采用<strong>存储器校验技术</strong>，通过添加冗余校验位，实现对数据错误的检测与纠正。</p>
<h3 id="6-1-编码的最小距离与检错纠错能力"><a href="#6-1-编码的最小距离与检错纠错能力" class="headerlink" title="6.1 编码的最小距离与检错纠错能力"></a>6.1 编码的最小距离与检错纠错能力</h3><p>编码的<strong>最小距离</strong>（L）是指任意两个合法编码之间二进制位数的最少差异。例如，编码 “00” 和 “01” 的最小距离为 1，编码 “000” 和 “011” 的最小距离为 2。</p>
<p>编码的检错、纠错能力与最小距离的关系满足公式：(L - 1 = D + C)（其中 D 为可检测错误的位数，C 为可纠正错误的位数，且 (D ≥ C)）。</p>
<ul>
<li>若需检测 D 位错误，需满足 (L ≥ D + 1)。例如，(D = 1) 时，(L ≥ 2)，即最小距离为 2 的编码可检测 1 位错误。</li>
<li>若需纠正 C 位错误，需满足 (L ≥ 2C + 1)。例如，(C = 1) 时，(L ≥ 3)，即最小距离为 3 的编码可纠正 1 位错误。</li>
<li>若需同时检测 D 位错误并纠正 C 位错误（(D &gt; C)），需满足 (L ≥ D + C + 1)。例如，(D = 2、C = 1) 时，(L ≥ 4)，即最小距离为 4 的编码可检测 2 位错误并纠正 1 位错误。</li>
</ul>
<h3 id="6-2-奇偶校验码"><a href="#6-2-奇偶校验码" class="headerlink" title="6.2 奇偶校验码"></a>6.2 奇偶校验码</h3><p>奇偶校验码是最简单的校验方式，通过在数据位后添加 1 位校验位，使编码的 “1” 的个数为奇数（奇校验）或偶数（偶校验），实现对 1 位错误的检测。</p>
<h4 id="6-2-1-奇校验"><a href="#6-2-1-奇校验" class="headerlink" title="6.2.1 奇校验"></a>6.2.1 奇校验</h4><p>奇校验要求数据位与校验位中 “1” 的总数为奇数。例如，数据 “0101”（含 2 个 “1”），奇校验位为 “1”，最终编码为 “01011”（含 3 个 “1”）；若数据传输过程中某 1 位出错（如 “01011” 变为 “01111”），“1” 的总数变为 4（偶数），则可检测出错误。</p>
<h4 id="6-2-2-偶校验"><a href="#6-2-2-偶校验" class="headerlink" title="6.2.2 偶校验"></a>6.2.2 偶校验</h4><p>偶校验要求数据位与校验位中 “1” 的总数为偶数。例如，数据 “0101”（含 2 个 “1”），偶校验位为 “0”，最终编码为 “01010”（含 2 个 “1”）；若数据传输过程中某 1 位出错（如 “01010” 变为 “01110”），“1” 的总数变为 3（奇数），则可检测出错误。</p>
<h4 id="6-2-3-局限性"><a href="#6-2-3-局限性" class="headerlink" title="6.2.3 局限性"></a>6.2.3 局限性</h4><p>奇偶校验码的最小距离为 2，仅能检测 1 位错误，无法检测 2 位及以上错误，也不能纠正任何错误。例如，数据 “01010”（偶校验）若变为 “01111”，“1” 的总数仍为 4（偶数），则无法检测出 2 位错误。因此，奇偶校验码仅适用于对数据可靠性要求较低的场景，如早期的低速存储器。</p>
<h3 id="6-3-汉明码"><a href="#6-3-汉明码" class="headerlink" title="6.3 汉明码"></a>6.3 汉明码</h3><p>汉明码是由理查德・汉明于 1950 年提出的一种具有<strong>1 位纠错能力</strong>的线性分组码，通过合理设置校验位的位置与取值，实现对 1 位错误的检测与纠正，对 2 位错误的检测。</p>
<h4 id="6-3-1-汉明码的校验位数量与位置"><a href="#6-3-1-汉明码的校验位数量与位置" class="headerlink" title="6.3.1 汉明码的校验位数量与位置"></a>6.3.1 汉明码的校验位数量与位置</h4><p>校验位数量（k）：若数据位数量为 n，则校验位数量需满足 2<sup>k</sup> ≥ n + k + 1。该公式的本质是：k 位校验位可产生 2<sup>k</sup> 种状态，需用 1 种状态表示 “无错”，剩余 2<sup>k</sup> - 1 种状态分别对应 n + k 位编码中 “某 1 位出错”（共 n + k 种可能），因此需 2<sup>k</sup> - 1 ≥ n + k，即 2<sup>k</sup> ≥ n + k + 1。</p>
<p>示例：</p>
<ul>
<li>当 n = 4（4 位数据）时，代入公式 2<sup>k</sup> ≥ 4 + k + 1：<ul>
<li>k = 2 时，2<sup>2</sup> = 4 &lt; 4 + 2 + 1 = 7，不满足；</li>
<li>k = 3 时，2<sup>3</sup> = 8 ≥ 4 + 3 + 1 = 8，满足，故取 k = 3。</li>
</ul>
</li>
<li>当 n = 8（8 位数据）时，代入公式 2<sup>k</sup> ≥ 8 + k + 1：<ul>
<li>k = 3 时，2<sup>3</sup> = 8 &lt; 8 + 3 + 1 = 12，不满足；</li>
<li>k = 4 时，2<sup>4</sup> = 16 ≥ 8 + 4 + 1 = 13，满足，故取 k = 4。</li>
</ul>
</li>
</ul>
<p>校验位位置：汉明码的校验位固定位于编码的 2<sup>i</sup>（i = 0, 1, 2, …, k-1）位置，即第 1、2、4、8、16 等位（编码位号从 1 开始计数，而非 0）。剩余位置用于存放数据位。</p>
<p>示例：当 n = 4、k = 3 时，汉明码共 4 + 3 = 7 位，位号为 1~7，其中：</p>
<ul>
<li>校验位位置：1（2<sup>0</sup>）、2（2<sup>1</sup>）、4（2<sup>2</sup>），对应校验位 C<sub>1</sub>、C<sub>2</sub>、C<sub>4</sub>；</li>
<li>数据位位置：3、5、6、7，对应数据位 D<sub>1</sub>、D<sub>2</sub>、D<sub>3</sub>、D<sub>4</sub>。</li>
</ul>
<p>汉明码位号分配如下表所示：</p>
<table>
<thead>
<tr>
<th>汉明码位号</th>
<th>1（2<sup>0</sup>）</th>
<th>2（2<sup>1</sup>）</th>
<th>3</th>
<th>4（2<sup>2</sup>）</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>编码类型</td>
<td>(C<sub>1</sub>)（校验位）</td>
<td>(C<sub>2</sub>)（校验位）</td>
<td>(D<sub>1</sub>)（数据位）</td>
<td>(C<sub>4</sub>)（校验位）</td>
<td>(D<sub>2</sub>)（数据位）</td>
<td>(D<sub>3</sub>)（数据位）</td>
<td>(D<sub>4</sub>)（数据位）</td>
</tr>
</tbody></table>
<h4 id="6-3-2-汉明码的校验位取值计算"><a href="#6-3-2-汉明码的校验位取值计算" class="headerlink" title="6.3.2 汉明码的校验位取值计算"></a>6.3.2 汉明码的校验位取值计算</h4><p>汉明码的校验位取值通过 “分组奇偶校验” 确定：将每个数据位分配到多个校验组，每个校验组对应 1 个校验位，校验位的取值需使该组内 “1” 的总数满足奇偶校验规则（通常为偶校验）。</p>
<p>分组规则：将汉明码的位号转换为二进制，第 i 个校验位（(C<sub>i</sub>)）对应二进制位的第 (i-1) 位（从 0 开始计数）为 1 的所有位号，这些位号对应的编码位构成该校验组。</p>
<p>示例（(n = 4、k = 3)，偶校验）：</p>
<ul>
<li>校验位 C<sub>1</sub>（对应位号 1，二进制 001）：负责二进制位第 0 位为 1 的位号，即 1（001）、3（011）、5（101）、7（111），对应编码位 C<sub>1</sub>、D<sub>1</sub>、D<sub>2</sub>、D<sub>4</sub>。C<sub>1</sub> 的取值需使该组内 “1” 的总数为偶数，即 C<sub>1</sub> = D<sub>1</sub> ⊕ D<sub>2</sub> ⊕ D<sub>4</sub>（”⊕”为异或运算，异或结果为 0 表示”1” 的总数为偶数）。</li>
<li>校验位 C<sub>2</sub>（对应位号 2，二进制 010）：负责二进制位第 1 位为 1 的位号，即 2（010）、3（011）、6（110）、7（111），对应编码位 C<sub>2</sub>、D<sub>1</sub>、D<sub>3</sub>、D<sub>4</sub>。C<sub>2</sub> 的取值为 C<sub>2</sub> = D<sub>1</sub> ⊕ D<sub>3</sub> ⊕ D<sub>4</sub>。</li>
<li>校验位 C<sub>4</sub>（对应位号 4，二进制 100）：负责二进制位第 2 位为 1 的位号，即 4（100）、5（101）、6（110）、7（111），对应编码位 C<sub>4</sub>、D<sub>2</sub>、D<sub>3</sub>、D<sub>4</sub>。C<sub>4</sub> 的取值为 C<sub>4</sub> = D<sub>2</sub> ⊕ D<sub>3</sub> ⊕ D<sub>4</sub>。</li>
</ul>
<h4 id="6-3-3-汉明码配置实例（偶校验）"><a href="#6-3-3-汉明码配置实例（偶校验）" class="headerlink" title="6.3.3 汉明码配置实例（偶校验）"></a>6.3.3 汉明码配置实例（偶校验）</h4><p>以数据 “0101”（即 (D_1 = 0)、(D_2 = 1)、(D_3 = 0)、(D_4 = 1)）为例，配置汉明码：</p>
<ol>
<li>确定校验位数量：(n = 4)，根据 (2^k \geq n + k + 1)，取 (k = 3)，汉明码共 7 位。</li>
<li>分配位号与类型：位 1（(C_1)）、位 2（(C_2)）、位 3（(D_1)）、位 4（(C_4)）、位 5（(D_2)）、位 6（(D_3)）、位 7（(D_4)）。</li>
<li>计算校验位：<ul>
<li>(C_1 = D_1 \oplus D_2 \oplus D_4 = 0 \oplus 1 \oplus 1 = 0)</li>
<li>(C_2 = D_1 \oplus D_3 \oplus D_4 = 0 \oplus 0 \oplus 1 = 1)</li>
<li>(C_4 = D_2 \oplus D_3 \oplus D_4 = 1 \oplus 0 \oplus 1 = 0)</li>
</ul>
</li>
<li>组合汉明码：按位号 1-7 排列，结果为 (C_1C_2D_1C_4D_2D_3D_4 = 0100101)。</li>
</ol>
<p>再以练习 “配置数据 0011 的汉明码（偶校验）” 为例：</p>
<ul>
<li>数据 “0011” 对应 (D_1 = 0)、(D_2 = 0)、(D_3 = 1)、(D_4 = 1)。</li>
<li>计算校验位：<ul>
<li>(C_1 = D_1 \oplus D_2 \oplus D_4 = 0 \oplus 0 \oplus 1 = 1)</li>
<li>(C_2 = D_1 \oplus D_3 \oplus D_4 = 0 \oplus 1 \oplus 1 = 0)</li>
<li>(C_4 = D_2 \oplus D_3 \oplus D_4 = 0 \oplus 1 \oplus 1 = 0)</li>
</ul>
</li>
<li>汉明码结果：1000011（位号 1-7：(1（C_1）、0（C_2）、0（D_1）、0（C_4）、0（D_2）、1（D_3）、1（D_4）)）。</li>
</ul>
<h4 id="6-3-4-汉明码的纠错过程"><a href="#6-3-4-汉明码的纠错过程" class="headerlink" title="6.3.4 汉明码的纠错过程"></a>6.3.4 汉明码的纠错过程</h4><ol>
<li><strong>接收汉明码</strong>：假设接收端收到的汉明码为 H<sub>1</sub>H<sub>2</sub>H<sub>3</sub>H<sub>4</sub>H<sub>5</sub>H<sub>6</sub>H<sub>7</sub>（对应位号 1-7）。</li>
<li>重新计算校验位（生成 P<sub>1</sub>、P<sub>2</sub>、P<sub>4</sub>）：<ul>
<li>P<sub>1</sub> = H<sub>1</sub> ⊕ H<sub>3</sub> ⊕ H<sub>5</sub> ⊕ H<sub>7</sub>（对应 C<sub>1</sub> 原校验组）</li>
<li>P<sub>2</sub> = H<sub>2</sub> ⊕ H<sub>3</sub> ⊕ H<sub>6</sub> ⊕ H<sub>7</sub>（对应 C<sub>2</sub> 原校验组）</li>
<li>P<sub>4</sub> = H<sub>4</sub> ⊕ H<sub>5</sub> ⊕ H<sub>6</sub> ⊕ H<sub>7</sub>（对应 C<sub>4</sub> 原校验组）</li>
</ul>
</li>
<li>生成错误位指示字 P<sub>4</sub>P<sub>2</sub>P<sub>1</sub>：<ul>
<li>若 P<sub>1</sub> = P<sub>2</sub> = P<sub>4</sub> = 0：无错误，直接提取数据位。</li>
<li>若 P<sub>4</sub>P<sub>2</sub>P<sub>1</sub> ≠ 000：指示字的十进制值即为错误位的位号，将该位取反（0 变 1，1 变 0）即可纠正错误。</li>
</ul>
</li>
</ol>
<h4 id="6-3-5-汉明码纠错实例"><a href="#6-3-5-汉明码纠错实例" class="headerlink" title="6.3.5 汉明码纠错实例"></a>6.3.5 汉明码纠错实例</h4><p>以 “例 4.5：接收汉明码为 0100111（偶校验），求原数据” 为例：</p>
<ol>
<li>接收汉明码位号分配：H<sub>1</sub>=0（C<sub>1</sub>）、H<sub>2</sub>=1（C<sub>2</sub>）、H<sub>3</sub>=0（D<sub>1</sub>）、H<sub>4</sub>=0（C<sub>4</sub>）、H<sub>5</sub>=1（D<sub>2</sub>）、H<sub>6</sub>=1（D<sub>3</sub>）、H<sub>7</sub>=1（D<sub>4</sub>）。</li>
<li>重新计算 P<sub>1</sub>、P<sub>2</sub>、P<sub>4</sub>：<ul>
<li>P<sub>1</sub> = H<sub>1</sub> ⊕ H<sub>3</sub> ⊕ H<sub>5</sub> ⊕ H<sub>7</sub> = 0 ⊕ 0 ⊕ 1 ⊕ 1 = 0</li>
<li>P<sub>2</sub> = H<sub>2</sub> ⊕ H<sub>3</sub> ⊕ H<sub>6</sub> ⊕ H<sub>7</sub> = 1 ⊕ 0 ⊕ 1 ⊕ 1 = 1</li>
<li>P<sub>4</sub> = H<sub>4</sub> ⊕ H<sub>5</sub> ⊕ H<sub>6</sub> ⊕ H<sub>7</sub> = 0 ⊕ 1 ⊕ 1 ⊕ 1 = 1</li>
</ul>
</li>
<li>生成错误位指示字：P<sub>4</sub>P<sub>2</sub>P<sub>1</sub> = 110，十进制值为 6，即第 6 位出错。</li>
<li>纠正错误：将第 6 位 H<sub>6</sub>=1 取反为 0，纠正后的汉明码为 0100101。</li>
<li>提取原数据：数据位为 H<sub>3</sub>H<sub>5</sub>H<sub>6</sub>H<sub>7</sub> = 0、1、0、1，即原数据为 “0101”。</li>
</ol>
<h3 id="6-4-循环冗余校验码（CRC）"><a href="#6-4-循环冗余校验码（CRC）" class="headerlink" title="6.4 循环冗余校验码（CRC）"></a>6.4 循环冗余校验码（CRC）</h3><p>循环冗余校验码（CRC）是一种广泛应用于通信和存储系统的校验方式，具有<strong>检错能力强</strong>（可检测出所有单比特错误、双比特错误、奇数个比特错误，以及大部分多比特错误）的特点，虽不能纠错，但因实现简单、检错效率高，成为硬盘、网络传输等场景的主流校验技术。</p>
<h4 id="6-4-1-CRC-的基本原理"><a href="#6-4-1-CRC-的基本原理" class="headerlink" title="6.4.1 CRC 的基本原理"></a>6.4.1 CRC 的基本原理</h4><ol>
<li><p>CRC 基于 “多项式运算”，将二进制数据视为多项式的系数，通过 “模 2 除法”（即异或运算，无进位和借位）生成校验位，具体步骤如下：</p>
<ol>
<li><p>**确定生成多项式 G (x)**：生成多项式由协议或标准规定，如</p>
<ul>
<li>CRC-16（G(x) = x<sup>16</sup> + x<sup>15</sup> + x<sup>2</sup> + 1）</li>
<li>CRC-32（G(x) = x<sup>32</sup> + x<sup>26</sup> + x<sup>23</sup> + x<sup>22</sup> + x<sup>16</sup> + x<sup>12</sup> + x<sup>11</sup> + x<sup>10</sup> + x<sup>8</sup> + x<sup>7</sup> + x<sup>5</sup> + x<sup>4</sup> + x<sup>2</sup> + x + 1）</li>
</ul>
<p>生成多项式的次数为 r，则校验位长度为 r 位。</p>
</li>
<li><p><strong>扩展数据位</strong>：在原数据 D (x) 末尾添加 r 个 0，得到扩展数据 D’(x) = D (x) × x<sup>r</sup>。</p>
</li>
<li><p><strong>模 2 除法</strong>：用扩展数据 D’(x) 除以生成多项式 G (x)（多项式系数按模 2 运算），得到余数 R (x)，余数的二进制表示即为校验位。</p>
</li>
<li><p><strong>组合 CRC 码</strong>：将校验位添加到原数据末尾，得到最终的 CRC 码 C (x) = D (x) × x<sup>r</sup> + R(x)。</p>
</li>
</ol>
</li>
</ol>
<h4 id="6-4-2-CRC-检错过程"><a href="#6-4-2-CRC-检错过程" class="headerlink" title="6.4.2 CRC 检错过程"></a>6.4.2 CRC 检错过程</h4><p>接收端收到 CRC 码后，进行以下操作：</p>
<ol>
<li>用接收的 CRC 码 C’(x) 除以约定的生成多项式 G (x)（模 2 除法）。</li>
<li>若余数为 0：判定数据无错误，提取原数据。</li>
<li>若余数不为 0：判定数据出错，需请求重传（因 CRC 无纠错能力）。</li>
</ol>
<h4 id="6-4-3-CRC-实例（以-CRC-3-为例）"><a href="#6-4-3-CRC-实例（以-CRC-3-为例）" class="headerlink" title="6.4.3 CRC 实例（以 CRC-3 为例）"></a>6.4.3 CRC 实例（以 CRC-3 为例）</h4><p>假设原数据为 “1010”（4 位），生成多项式 (G(x) = x<sup>3</sup> + x + 1)（对应二进制 “1011”，次数 (r = 3)）：</p>
<ol>
<li><p>扩展数据：在 “1010” 末尾加 3 个 0，得到 “1010000”。</p>
</li>
<li><p>模 2 除法：用 “1010000” 除以 “1011”：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">  1001</span><br><span class="line">1011)1010000</span><br><span class="line">     1011</span><br><span class="line">     ----</span><br><span class="line">       0100</span><br><span class="line">       0000</span><br><span class="line">       ----</span><br><span class="line">       1000</span><br><span class="line">       0000</span><br><span class="line">       ----</span><br><span class="line">       1000</span><br><span class="line">       1011</span><br><span class="line">       ----</span><br><span class="line">         011（余数）</span><br></pre></td></tr></tbody></table></figure>

<p>余数为 “011”，即校验位为 3 位 “011”。</p>
</li>
<li><p>组合 CRC 码：原数据 “1010” + 校验位 “011”，得到 CRC 码 “1010011”。</p>
</li>
<li><p>检错验证：接收端用 “1010011” 除以 “1011”，余数为 0，判定无错误，提取原数据 “1010”。</p>
</li>
</ol>
<h2 id="七、提高访存速度的措施"><a href="#七、提高访存速度的措施" class="headerlink" title="七、提高访存速度的措施"></a>七、提高访存速度的措施</h2><p>CPU 运算速度不断提升（如现代 CPU 主频达 3-5GHz，运算周期为纳秒级），而主存存取速度相对滞后（DRAM 存取周期为几十到几百纳秒），形成 “CPU - 主存速度差”。为缩小这一差距，需从硬件设计、体系结构等多维度优化，以下是核心措施的详细解析。</p>
<h3 id="7-1-采用高速存储器件"><a href="#7-1-采用高速存储器件" class="headerlink" title="7.1 采用高速存储器件"></a>7.1 采用高速存储器件</h3><p>从硬件底层提升存储速度，是最直接的优化方式，核心是选用速度更快的存储芯片，常见技术路径如下：</p>
<h4 id="7-1-1-高速-SRAM-芯片"><a href="#7-1-1-高速-SRAM-芯片" class="headerlink" title="7.1.1 高速 SRAM 芯片"></a>7.1.1 高速 SRAM 芯片</h4><p>SRAM 基于触发器存储数据，无需刷新，存取速度可达 5-20ns，远快于 DRAM（50-100ns）。在 Cache 设计中，通常采用高速 SRAM 芯片（如高速异步 SRAM、同步 SRAM），确保 Cache 能匹配 CPU 的高速访问需求。例如，CPU L1 Cache 多采用定制化高速 SRAM，存取周期仅 1-3ns，与 CPU 运算周期基本同步。</p>
<h4 id="7-1-2-增强型-DRAM-芯片"><a href="#7-1-2-增强型-DRAM-芯片" class="headerlink" title="7.1.2 增强型 DRAM 芯片"></a>7.1.2 增强型 DRAM 芯片</h4><p>针对 DRAM 速度瓶颈，通过优化芯片结构与控制逻辑，推出增强型 DRAM 芯片，典型代表包括：</p>
<ul>
<li><strong>快速页模式 DRAM（FPM DRAM）</strong>：传统 DRAM 每次访问需重新选址（行地址 + 列地址），FPM DRAM 支持 “页模式”—— 选中一行后，可连续访问该行内不同列地址的存储单元，无需重复发送行地址，减少地址传输延迟，连续访问速度提升 2-3 倍。</li>
<li><strong>扩展数据输出 DRAM（EDO DRAM）</strong>：在 FPM DRAM 基础上，延长数据输出时间窗口，允许在当前数据未完全输出时，提前发送下一列地址，进一步缩短连续访问的间隔时间，速度比 FPM DRAM 再提升 10%-20%。</li>
<li><strong>突发模式 DRAM（Burst DRAM）</strong>：支持 “突发传输”，一次地址传输后，可连续传输 2、4 或 8 个数据单元，减少地址总线的占用次数，适合 CPU 对连续数据的批量访问（如读取指令流、数组数据）。</li>
</ul>
<h3 id="7-2-引入-Cache-主存层次结构"><a href="#7-2-引入-Cache-主存层次结构" class="headerlink" title="7.2 引入 Cache - 主存层次结构"></a>7.2 引入 Cache - 主存层次结构</h3><p>Cache - 主存层次结构是解决 CPU - 主存速度差的 “经典方案”，核心是利用 “程序局部性原理”，将 CPU 近期高频访问的数据和指令暂存于高速 Cache 中，减少 CPU 对主存的直接访问次数。</p>
<h4 id="7-2-1-程序局部性原理（Cache-设计的理论基础）"><a href="#7-2-1-程序局部性原理（Cache-设计的理论基础）" class="headerlink" title="7.2.1 程序局部性原理（Cache 设计的理论基础）"></a>7.2.1 程序局部性原理（Cache 设计的理论基础）</h4><p>程序执行过程中，对存储器的访问具有明显的局部性，分为 “时间局部性” 和 “空间局部性”：</p>
<ul>
<li><strong>时间局部性</strong>：近期访问过的存储单元，在短期内大概率会被再次访问。例如，循环程序中的循环变量、判断条件，会被反复读取。</li>
<li><strong>空间局部性</strong>：若某一存储单元被访问，其相邻的存储单元在短期内也大概率会被访问。例如，数组数据按地址连续存储，访问数组元素时，会依次访问相邻单元；指令按顺序执行，也会连续访问相邻指令地址。</li>
</ul>
<p>基于局部性原理，Cache 只需存储 CPU 近期高频访问的 “数据块”（通常为 32B、64B 或 128B），即可实现较高的 “Cache 命中率”（CPU 访问 Cache 成功的概率），从而大幅减少主存访问次数。</p>
<h4 id="7-2-2-Cache-的基本结构"><a href="#7-2-2-Cache-的基本结构" class="headerlink" title="7.2.2 Cache 的基本结构"></a>7.2.2 Cache 的基本结构</h4><p>Cache 通常由<strong>Cache 存储体</strong>、<strong>地址映射机构</strong>、<strong>替换机构</strong>和<strong>读写控制电路</strong>组成，结构逻辑如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">CPU &lt;-&gt; 地址映射机构 &lt;-&gt; Cache 存储体</span><br><span class="line">           ^                    ^</span><br><span class="line">           |                    |</span><br><span class="line">           +--------------------+</span><br><span class="line">                  |</span><br><span class="line">                  v</span><br><span class="line">              主存</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p><strong>Cache 存储体</strong>：由高速 SRAM 组成，按 “块” 划分存储单元，每个块对应主存中的一个数据块，且包含 “有效位”（标记块中数据是否有效）、“脏位”（标记块中数据是否被修改，需回写主存）等控制位。</p>
</li>
<li><p><strong>地址映射机构</strong>：负责将 CPU 发出的主存地址，映射为 Cache 地址，确定主存数据块在 Cache 中的存储位置。常见的映射方式有直接映射、全相联映射和组相联映射。</p>
</li>
<li><p><strong>替换机构</strong>：当 Cache 满时，需替换掉 “近期最不可能被访问” 的 Cache 块，为新数据块腾出空间。核心替换算法有 FIFO（先进先出）、LRU（最近最少使用）和 LFU（最不经常使用），其中 LRU 算法因契合局部性原理，命中率最高，应用最广泛。</p>
</li>
<li><p>读写控制电路：控制 Cache 与 CPU、Cache 与主存之间的数据传输，处理 “命中” 和 “缺失” 两种场景：</p>
<ul>
<li>命中：CPU 直接与 Cache 交换数据。</li>
</ul>
</li>
<li><p>缺失：从主存读取数据块到 Cache（读缺失），或将修改后的 Cache 块写回主存（写缺失）。</p>
</li>
</ul>
<h4 id="7-2-3-地址映射方式（Cache-核心技术）"><a href="#7-2-3-地址映射方式（Cache-核心技术）" class="headerlink" title="7.2.3 地址映射方式（Cache 核心技术）"></a>7.2.3 地址映射方式（Cache 核心技术）</h4><p>不同地址映射方式决定了主存块在 Cache 中的存储灵活性和查找效率，三种主流映射方式的对比与解析如下：</p>
<h5 id="7-2-3-1-直接映射"><a href="#7-2-3-1-直接映射" class="headerlink" title="7.2.3.1 直接映射"></a>7.2.3.1 直接映射</h5><ul>
<li><p><strong>映射规则</strong>：将主存空间按 Cache 容量划分为若干 “区”，每个主存区的第 i 块，固定映射到 Cache 的第 i 块（即 (Cache 块号 = 主存块号 \mod Cache 总块数)）。</p>
</li>
<li><p>地址结构：CPU 主存地址分为 “主存区号”“Cache 块号”“块内地址” 三部分：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">主存区号（标记位） | Cache 块号 | 块内地址</span><br></pre></td></tr></tbody></table></figure>

<p>例如，Cache 容量为(2<sup>c</sup>)块，每块大小为(2<sup>b</sup>)字节，则 Cache 块号占c位，块内地址占b位，剩余高位为主存区号（标记位）。</p>
</li>
<li><p>查找过程：CPU 访问时，根据主存地址的 “Cache 块号” 定位到 Cache 对应块，对比 “主存区号” 与 Cache 块的 “标记位”：</p>
<ul>
<li><p>若标记位匹配且有效位为 1（表示 Cache 块数据有效）：命中，用 “块内地址” 读取 Cache 块中的数据。</p>
</li>
<li><p>若标记位不匹配或有效位为 0：缺失，从主存读取对应数据块，替换到 Cache 对应块中，并更新标记位和有效位。</p>
</li>
</ul>
</li>
<li><p><strong>优点</strong>：地址映射逻辑简单，查找速度快（仅需按块号定位 + 标记位对比），硬件实现成本低。</p>
</li>
<li><p><strong>缺点</strong>：存在 “冲突失效”—— 当多个主存块映射到同一个 Cache 块时，会频繁替换，导致命中率下降。例如，Cache 仅有 2 块，主存块 0、2、4 均映射到 Cache 块 0，若 CPU 交替访问主存块 0 和 2，会持续触发 Cache 缺失。</p>
</li>
<li><p><strong>应用场景</strong>：适用于 Cache 容量较小、对硬件复杂度敏感的场景，如早期计算机的 L1 Cache 或嵌入式系统。</p>
</li>
</ul>
<h4 id="7-2-3-2-全相联映射"><a href="#7-2-3-2-全相联映射" class="headerlink" title="7.2.3.2 全相联映射"></a>7.2.3.2 全相联映射</h4><ul>
<li><p><strong>映射规则</strong>：主存中的任意一块，可映射到 Cache 中的任意一块，无固定位置限制。</p>
</li>
<li><p><strong>地址结构</strong>：CPU 主存地址仅分为 “主存块号（标记位）” 和 “块内地址” 两部分：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">主存块号（标记位） | 块内地址</span><br></pre></td></tr></tbody></table></figure>

<p>无需 “Cache 块号”，因主存块可存于任意 Cache 块。</p>
</li>
<li><p><strong>查找过程</strong>：CPU 访问时，需将主存地址的 “标记位” 与 Cache 中所有有效块的 “标记位” 逐一对比（即 “全相联比较”）：</p>
<ul>
<li>若找到匹配标记位的 Cache 块：命中，用 “块内地址” 读取数据。</li>
<li>若未找到匹配标记位，或所有 Cache 块均无效：缺失，从主存读取数据块，根据替换算法（如 LRU）选择一个 Cache 块替换，并更新标记位和有效位。</li>
</ul>
</li>
<li><p><strong>优点</strong>：无冲突失效，Cache 空间利用率高，命中率远高于直接映射。</p>
</li>
<li><p><strong>缺点</strong>：全相联比较逻辑复杂，硬件实现成本高（需大量比较器并行工作），查找速度慢（对比次数随 Cache 块数增加而增多）。</p>
</li>
<li><p><strong>应用场景</strong>：适用于 Cache 容量极小的场景，如 CPU 中的 TLB（Translation Lookaside Buffer，地址转换缓存），因 TLB 块数少（通常几十到几百块），全相联比较的复杂度可控。</p>
</li>
</ul>
<h4 id="7-2-3-3-组相联映射（直接映射与全相联映射的折中）"><a href="#7-2-3-3-组相联映射（直接映射与全相联映射的折中）" class="headerlink" title="7.2.3.3 组相联映射（直接映射与全相联映射的折中）"></a>7.2.3.3 组相联映射（直接映射与全相联映射的折中）</h4><ul>
<li><p><strong>映射规则</strong>：将 Cache 划分为若干 “组”，每组包含若干 “块”；主存中的任意一块，先通过 “主存块号 mod Cache 组数” 确定映射到 Cache 的 “组号”，再在该组内任意选择一块存储（组内全相联）。</p>
</li>
<li><p><strong>核心参数</strong>：“组相联度”= 每组块数，常见的有 2 路组相联（每组 2 块）、4 路组相联（每组 4 块）、8 路组相联（每组 8 块）。</p>
</li>
<li><p><strong>地址结构</strong>：CPU 主存地址分为 “主存块号高位（标记位）”“Cache 组号”“块内地址” 三部分：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">主存块号高位（标记位） | Cache 组号 | 块内地址</span><br></pre></td></tr></tbody></table></figure>

<p>例如，Cache 共 (2<sup>g</sup>) 组，每组 (2<sup>s</sup>) 块（组相联度 (2<sup>s</sup>) ），每块 (2<sup>g</sup>)  字节，则 Cache 组号占 g 位，块内地址占 b 位，剩余高位为标记位。</p>
</li>
<li><p><strong>查找过程</strong>：</p>
<ol>
<li>根据主存地址的 “Cache 组号”，定位到 Cache 中的目标组。</li>
<li>将主存地址的 “标记位” 与目标组内所有有效块的 “标记位” 逐一对比（组内全相联比较）。</li>
<li>若找到匹配标记位的 Cache 块：命中，用 “块内地址” 读取数据。</li>
<li>若未找到匹配标记位，或目标组内无有效块：缺失，从主存读取数据块，在目标组内按替换算法选择一块替换，并更新标记位和有效位。</li>
</ol>
</li>
<li><p><strong>字符图示意（4 路组相联，Cache 共 4 组，每组 4 块）</strong>：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Cache 组 0：块 0-3（组内 4 块，全相联）</span><br><span class="line">  Cache 组 1：块 4-7（组内 4 块，全相联）</span><br><span class="line">Cache 组 2：块 8-11（组内 4 块，全相联）</span><br><span class="line">  Cache 组 3：块 12-15（组内 4 块，全相联）</span><br><span class="line">主存块 X → 组号 = X mod 4 → 存入对应组内任意块</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li>冲突失效远少于直接映射：组相联度越高，组内块数越多，冲突失效概率越低。</li>
<li>查找复杂度低于全相联映射：仅需在目标组内比较，无需遍历所有 Cache 块，硬件实现成本可控。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：查找速度略慢于直接映射，组相联度越高，组内比较次数越多，硬件复杂度越高。</p>
</li>
<li><p><strong>应用场景</strong>：当前主流 CPU 的 Cache 设计（如 L1、L2、L3 Cache），通常采用 4 路、8 路或 16 路组相联，在命中率与硬件复杂度间取得平衡。</p>
</li>
</ul>
<h4 id="7-2-4-Cache-的写策略（解决-Cache-与主存数据一致性）"><a href="#7-2-4-Cache-的写策略（解决-Cache-与主存数据一致性）" class="headerlink" title="7.2.4 Cache 的写策略（解决 Cache 与主存数据一致性）"></a>7.2.4 Cache 的写策略（解决 Cache 与主存数据一致性）</h4><p>当 CPU 写入数据时，需确保 Cache 与主存中的数据一致，常见的写策略有 “写直达” 和 “写回”，配合 “写分配” 和 “非写分配” 机制，形成四种组合策略。</p>
<h5 id="7-2-4-1-写直达（Write-Through）"><a href="#7-2-4-1-写直达（Write-Through）" class="headerlink" title="7.2.4.1 写直达（Write-Through）"></a>7.2.4.1 写直达（Write-Through）</h5><ul>
<li><p><strong>核心逻辑</strong>：CPU 写入数据时，同时更新 Cache 和主存中的数据，确保 Cache 与主存数据实时一致。</p>
</li>
<li><p>写缺失处理：</p>
<ul>
<li>写分配：先从主存读取缺失的数据块到 Cache，再更新 Cache 和主存。</li>
<li>非写分配：不读取主存数据块到 Cache，直接更新主存（仅适用于 “写直达”，因无需维护 Cache 与主存一致性）。</li>
</ul>
</li>
<li><p><strong>优点</strong>：数据一致性好，主存始终保存最新数据，无需 “脏位”（标记 Cache 块是否被修改），硬件逻辑简单。</p>
</li>
<li><p><strong>缺点</strong>：每次写操作都需访问主存，主存带宽压力大，写速度受主存速度限制（主存写速度远慢于 Cache）。</p>
</li>
<li><p><strong>应用场景</strong>：适用于主存带宽充足、对数据一致性要求极高的场景，如数据库服务器的内存 Cache。</p>
</li>
</ul>
<h5 id="7-2-4-2-写回（Write-Back）"><a href="#7-2-4-2-写回（Write-Back）" class="headerlink" title="7.2.4.2 写回（Write-Back）"></a>7.2.4.2 写回（Write-Back）</h5><ul>
<li><strong>核心逻辑</strong>：CPU 写入数据时，仅更新 Cache 中的数据，不立即更新主存；仅当 Cache 块被替换时，才将 “脏块”（被修改过的 Cache 块，需通过 “脏位” 标记）的数据写回主存。</li>
<li><strong>写缺失处理</strong>：仅支持 “写分配”—— 先从主存读取缺失的数据块到 Cache，再更新 Cache（主存暂不更新）。</li>
<li><strong>优点</strong>：大幅减少主存写操作次数，降低主存带宽压力，写速度接近 Cache 速度（仅需更新 Cache）。</li>
<li><strong>缺点</strong>：需额外维护 “脏位”，硬件逻辑略复杂；若 Cache 掉电（如突然断电），未写回主存的 “脏块” 数据会丢失，需配合备用电源或非易失性 Cache 解决。</li>
<li><strong>应用场景</strong>：当前主流 CPU 的 Cache 设计（如 L1、L2 Cache），因能有效提升写操作效率，契合 CPU 高频写需求。</li>
</ul>
<h3 id="7-3-调整主存结构（多体并行与单体多字）"><a href="#7-3-调整主存结构（多体并行与单体多字）" class="headerlink" title="7.3 调整主存结构（多体并行与单体多字）"></a>7.3 调整主存结构（多体并行与单体多字）</h3><p>通过优化主存的内部组织结构，利用并行性提升数据访问效率，核心方案包括 “单体多字系统” 和 “多体并行系统”。</p>
<h4 id="7-3-1-单体多字系统"><a href="#7-3-1-单体多字系统" class="headerlink" title="7.3.1 单体多字系统"></a>7.3.1 单体多字系统</h4><ul>
<li><p><strong>核心原理</strong>：在一个存储体内，设置多个并行的存储单元阵列，每个阵列存储 1 个字（如 8 位）；CPU 一次可读取多个字（如 4 个字，共 32 位），通过增加 “每次访问的数据量” 提升存储器带宽（带宽 = 每次访问数据量 / 存取周期）。</p>
</li>
<li><p><strong>结构示意（以 4 字并行为例）</strong>：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">主存控制器 → 地址寄存器 → 地址译码器</span><br><span class="line">                          ↓</span><br><span class="line">存储体：[字 0 单元阵列] [字 1 单元阵列] [字 2 单元阵列] [字 3 单元阵列]</span><br><span class="line">                          ↓</span><br><span class="line">数据寄存器组：[字 0 寄存器] [字 1 寄存器] [字 2 寄存器] [字 3 寄存器] → 数据总线（32 位）</span><br></pre></td></tr></tbody></table></figure>

<p>当 CPU 发出地址 “0” 时，地址译码器同时选中 4 个单元阵列的 “0 号单元”，读取 4 个字（字 0、字 1、字 2、字 3），存入对应数据寄存器，再通过 32 位数据总线传输给 CPU。</p>
</li>
<li><p><strong>优点</strong>：结构简单，无需复杂的多体控制逻辑，仅通过增加并行存储单元阵列即可提升带宽。</p>
</li>
<li><p><strong>缺点</strong>：仅适用于 “连续数据访问”（如读取指令流、数组数据），若 CPU 访问非连续地址（如随机访问离散数据），会读取大量无用数据，导致带宽浪费；且不能减少单次存取周期，仅能提升连续访问时的吞吐量。</p>
</li>
<li><p><strong>应用场景</strong>：早期计算机主存设计，或对连续数据访问依赖度高的专用计算设备（如信号处理器）。</p>
</li>
</ul>
<h4 id="7-3-2-多体并行系统（核心方案）"><a href="#7-3-2-多体并行系统（核心方案）" class="headerlink" title="7.3.2 多体并行系统（核心方案）"></a>7.3.2 多体并行系统（核心方案）</h4><ul>
<li><strong>核心原理</strong>：将主存划分为多个相互独立的 “存储体”（每个存储体包含完整的地址译码、读写控制和数据寄存器），每个存储体可独立执行读 / 写操作；通过 “并行访问多个存储体” 或 “流水线访问多个存储体”，减少整体访问延迟，提升带宽。</li>
<li><strong>分类</strong>：根据地址编址方式，分为 “高位交叉编址” 和 “低位交叉编址”，其中低位交叉编址是提升速度的关键。</li>
</ul>
<h5 id="7-3-2-1-高位交叉编址（顺序编址）"><a href="#7-3-2-1-高位交叉编址（顺序编址）" class="headerlink" title="7.3.2.1 高位交叉编址（顺序编址）"></a>7.3.2.1 高位交叉编址（顺序编址）</h5><ul>
<li><p>编址规则：地址的 “高位” 用于选择存储体（体号），“低位” 用于选择存储体内的单元（体内地址）；每个存储体存储连续的地址空间，即存储体 0 存地址 0<del>2<sup>m</sup> - 1，存储体 1 存地址 2<sup>m</sup></del>2<sup>m+1</sup> - 1（其中 m 为体内地址位数）。</p>
</li>
<li><p><strong>地址结构</strong>：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">体号（高位） | 体内地址（低位）</span><br></pre></td></tr></tbody></table></figure>

<p>例如，4 个存储体，体内地址 10 位（每个存储体容量 (2<sup>10&gt;</sup> = 1KB)），则地址高位 2 位为体号（00~11），低位 10 位为体内地址。</p>
</li>
<li><p><strong>访问特点</strong>：CPU 按地址顺序访问时，通常仅访问一个存储体（如连续读取地址 0、1、2 时，仅访问存储体 0），无法发挥多体并行优势；仅当 CPU 随机访问不同存储体的地址时，才能并行访问。</p>
</li>
<li><p><strong>优点</strong>：地址分配简单，存储体独立性强，适合多处理器系统（不同处理器可独立访问不同存储体）。</p>
</li>
<li><p><strong>缺点</strong>：无法利用程序的空间局部性（顺序访问）提升速度，并行性差。</p>
</li>
<li><p><strong>应用场景</strong>：多处理器系统的共享主存，或对存储体独立性要求高的场景。</p>
</li>
</ul>
<h5 id="7-3-2-2-低位交叉编址（交叉编址，核心优化）"><a href="#7-3-2-2-低位交叉编址（交叉编址，核心优化）" class="headerlink" title="7.3.2.2 低位交叉编址（交叉编址，核心优化）"></a>7.3.2.2 低位交叉编址（交叉编址，核心优化）</h5><ul>
<li><p><strong>编址规则</strong>：地址的 “低位” 用于选择存储体（体号），“高位” 用于选择存储体内的单元（体内地址）；相邻地址的数据存储在不同存储体中，即地址 i 对应的体号 = (i mod 存储体数)。</p>
</li>
<li><p><strong>地址结构</strong>：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">体内地址（高位） | 体号（低位）</span><br></pre></td></tr></tbody></table></figure>

<p>例如，4 个存储体（体号 0~3），体内地址 10 位，则地址 i 的二进制低 2 位为体号，高 10 位为体内地址。地址 0（000…000）→ 体 0，地址 1（000…001）→ 体 1，地址 2（000…010）→ 体 2，地址 3（000…011）→ 体 3，地址 4（000…100）→ 体 0，以此类推。</p>
</li>
<li><p>访问特点（流水线访问）：利用 “存储体存取周期&gt; 总线传输周期” 的特性，实现流水线式访问 —— 当一个存储体正在执行存取操作（占用存取周期 T）时</p>
</li>
<li><p>CPU 可向另一个存储体发送访问命令（占用总线传输周期 τ），从而在 T 时间内完成多个存储体的访问。</p>
</li>
<li><p>关键条件：为实现无冲突流水线，需满足 T = k × τ（k 为存储体数），即存储体存取周期是总线传输周期的 k 倍。</p>
</li>
<li><p>示意图（4 体低位交叉，T = 4τ）：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">时间轴 → τ1 τ2 τ3 τ4 τ5 τ6 τ7 τ8</span><br><span class="line">存储体 0：[存取]       [存取]       （T=4τ，τ1-τ4 执行第一次存取，τ5-τ8 执行第二次）</span><br><span class="line">存储体 1：    [存取]       [存取]    （τ2-τ5 执行第一次存取，τ6-τ9 执行第二次）</span><br><span class="line">存储体 2：        [存取]       [存取]  （τ3-τ6 执行第一次存取，τ7-τ10 执行第二次）</span><br><span class="line">存储体 3：            [存取]       [存取]（τ4-τ7 执行第一次存取，τ8-τ11 执行第二次）</span><br><span class="line">总线传输： 发令  发令  发令  发令  发令  发令  发令  发令</span><br></pre></td></tr></tbody></table></figure>

<p>从 τ1 开始，CPU 依次向存储体 0~3 发送访问命令（τ1 发体 0，τ2 发体 1，τ3 发体 2，τ4 发体 3）；τ4 时，存储体 0 完成第一次存取，τ5 时存储体 1 完成，以此类推，每间隔 τ就有一个存储体完成存取，实现 “流水线输出”。</p>
</li>
<li><p><strong>性能提升计算</strong>：</p>
<ul>
<li><p>单体存储器：连续读取 k 个字，总时间 = k × T。</p>
</li>
<li><p>k 体低位交叉存储器：连续读取 k 个字，总时间 = T + (k - 1) × τ；若 T = kτ，则总时间 = kτ + (k - 1)τ = (2k - 1)τ，远小于单体存储器的 k × kτ = k<sup>2</sup>τ。</p>
</li>
<li><p>示例：4 体交叉，T = 40ns（τ = 10ns），连续读 4 个字：</p>
<ul>
<li>单体总时间 = 4 × 40 = 160ns。</li>
<li>交叉总时间 = 40 + (4 - 1) × 10 = 70ns，速度提升约 2.3 倍。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>优点</strong>：能充分利用程序的空间局部性（连续地址访问），通过流水线并行大幅提升带宽和访问效率，是当前主存结构的主流设计。</p>
</li>
<li><p><strong>缺点</strong>：地址编址逻辑复杂，需精确控制存储体的访问时序，避免 “体冲突”（多个访问请求同时指向同一个存储体）；若 CPU 随机访问，并行优势会减弱。</p>
</li>
<li><p><strong>应用场景</strong>：现代计算机的主存设计（如 DDR 内存控制器），几乎均采用低位交叉编址的多体并行结构。</p>
</li>
</ul>
<h3 id="7-4-采用高性能存储芯片（DRAM-技术演进）"><a href="#7-4-采用高性能存储芯片（DRAM-技术演进）" class="headerlink" title="7.4 采用高性能存储芯片（DRAM 技术演进）"></a>7.4 采用高性能存储芯片（DRAM 技术演进）</h3><p>随着半导体技术发展，DRAM 芯片不断迭代，通过优化结构、同步时序、增加并行通道等方式提升速度，主流技术包括 SDRAM、DDR SDRAM、RDRAM 及带 Cache 的 DRAM，以下是各技术的深度解析：</p>
<h4 id="7-4-1-SDRAM（同步-DRAM）"><a href="#7-4-1-SDRAM（同步-DRAM）" class="headerlink" title="7.4.1 SDRAM（同步 DRAM）"></a>7.4.1 SDRAM（同步 DRAM）</h4><ul>
<li><strong>技术突破</strong>：突破传统 DRAM “异步工作” 的局限，采用 “系统时钟同步” 机制 ——SDRAM 的所有操作（地址传输、数据读写、刷新）均在系统时钟的上升沿（或下降沿）触发，CPU 无需等待存储器的异步响应信号，大幅减少等待延迟。</li>
<li><strong>核心结构</strong>：<ul>
<li><strong>时钟同步单元</strong>：接收系统时钟信号，同步所有内部操作时序，确保与 CPU、北桥芯片的时序匹配。</li>
<li><strong>突发模式控制器</strong>：支持 “突发传输”（Burst Transfer），一次地址传输后，可连续传输 2、4、8 或 16 个数据单元，减少地址总线的占用次数，提升连续数据访问效率（契合程序空间局部性）。</li>
<li><strong>Bank 分组结构</strong>：将存储体划分为多个独立的 Bank（如 2 个或 4 个 Bank），可同时对不同 Bank 进行行激活操作，当一个 Bank 处于数据读写阶段时，另一个 Bank 可提前完成行激活，隐藏行激活延迟（行激活是 DRAM 中耗时较长的操作，约占存取周期的 50%）。</li>
</ul>
</li>
<li><strong>性能指标</strong>：以 PC133 SDRAM 为例，系统时钟频率为 133MHz，数据总线宽度为 64 位（8 字节），则理论带宽 = 133MHz × 8B = 1064MB/s（约 1GB/s），远高于传统 EDO DRAM（约 160MB/s）。</li>
<li><strong>应用场景</strong>：20 世纪 90 年代末至 21 世纪初的主流主存芯片，广泛应用于 Pentium III、Athlon 等 CPU 平台。</li>
</ul>
<h4 id="7-4-2-DDR-SDRAM（双倍数据率同步-DRAM）"><a href="#7-4-2-DDR-SDRAM（双倍数据率同步-DRAM）" class="headerlink" title="7.4.2 DDR SDRAM（双倍数据率同步 DRAM）"></a>7.4.2 DDR SDRAM（双倍数据率同步 DRAM）</h4><ul>
<li><strong>技术演进</strong>：在 SDRAM 基础上，采用 “双倍数据率” 技术 —— 在系统时钟的上升沿和下降沿均传输数据，使数据传输速率翻倍，同时保留 SDRAM 的时钟同步、突发传输、Bank 分组等核心优势。</li>
<li><strong>关键改进</strong>：<ul>
<li><strong>双边沿数据传输</strong>：传统 SDRAM 仅在时钟上升沿传输数据，DDR SDRAM 则在上升沿和下降沿各传输一次数据。例如，系统时钟频率为 200MHz，DDR SDRAM 的数据传输频率为 400MHz（即 DDR400）。</li>
<li><strong>差分信号传输</strong>：地址和控制信号采用差分信号（如 DDR2 及后续版本），抗干扰能力更强，支持更高的时钟频率（如 DDR3 支持 800-2133MHz 时钟，DDR4 支持 2133-3200MHz 时钟）。</li>
<li><strong>Bank 扩展与时序优化</strong>：DDR2 及后续版本增加 Bank 数量（如 DDR4 支持 8 个 Bank），优化行激活、列读写的时序参数，进一步减少延迟；同时引入 “自刷新”“部分刷新” 机制，降低功耗（如移动设备中的低功耗 DDR 芯片）。</li>
</ul>
</li>
<li><strong>性能迭代（以主流规格为例）</strong>：<ul>
<li>DDR（DDR1）：时钟频率 100-200MHz，数据传输频率 200-400MHz，带宽 1.6-3.2GB/s。</li>
<li>DDR2：时钟频率 200-533MHz，数据传输频率 400-1066MHz，带宽 3.2-8.5GB/s。</li>
<li>DDR3：时钟频率 400-1066MHz，数据传输频率 800-2133MHz，带宽 6.4-17GB/s。</li>
<li>DDR4：时钟频率 1066-1600MHz，数据传输频率 2133-3200MHz，带宽 17-25.6GB/s。</li>
<li>DDR5：时钟频率 1600-3200MHz，数据传输频率 3200-6400MHz，带宽 25.6-51.2GB/s，且支持 “通道拆分”（将 64 位总线拆分为两个 32 位通道），进一步提升并行性。</li>
</ul>
</li>
<li><strong>应用场景</strong>：当前主流计算机（台式机、笔记本、服务器）的主存芯片，从 DDR2 开始成为行业标准，DDR4 目前是消费级市场主流，DDR5 正逐步普及。</li>
</ul>
<h4 id="7-4-3-RDRAM（Rambus-DRAM）"><a href="#7-4-3-RDRAM（Rambus-DRAM）" class="headerlink" title="7.4.3 RDRAM（Rambus DRAM）"></a>7.4.3 RDRAM（Rambus DRAM）</h4><ul>
<li><strong>技术定位</strong>：由 Rambus 公司开发的高性能 DRAM 技术，核心目标是解决传统 DRAM “并行总线带宽瓶颈”，采用 “串行总线架构” 提升数据传输速率。</li>
<li><strong>核心特点</strong>：<ul>
<li><strong>串行总线架构</strong>：摒弃传统 DRAM 的 64 位并行数据总线，采用 16 位串行总线（Rambus Channel），通过极高的总线频率（如 800MHz）实现高带宽。例如，单通道 RDRAM 数据传输速率为 1.6GB/s（800MHz × 2B），双通道可达到 3.2GB/s。</li>
<li><strong>点对点连接</strong>：每个 RDRAM 芯片与内存控制器采用点对点连接，而非传统并行总线的共享连接，减少总线竞争和信号干扰，支持多芯片串联（如一条通道可连接 8 个 RDRAM 芯片）。</li>
<li><strong>数据包传输</strong>：数据和命令以 “数据包” 形式传输，包含地址、控制和数据信息，提升总线利用率，适合对延迟敏感的应用（如游戏、图形渲染）。</li>
</ul>
</li>
<li><strong>技术局限</strong>：<ul>
<li><strong>成本高</strong>：串行总线架构的芯片设计和制造成本高，且需专用内存控制器和主板，兼容性差（仅少数 CPU 平台支持，如早期 Intel Pentium 4）。</li>
<li><strong>延迟问题</strong>：尽管带宽高，但串行总线的数据包处理延迟高于传统 DDR SDRAM，在随机访问场景下性能优势不明显。</li>
<li><strong>功耗大</strong>：高频率串行总线的功耗高于并行总线，不利于移动设备。</li>
</ul>
</li>
<li><strong>应用场景</strong>：早期主要应用于高端服务器、工作站及部分游戏主机（如 Nintendo GameCube），因成本和兼容性问题，未在消费级市场普及，逐渐被 DDR SDRAM 取代。</li>
</ul>
<h4 id="7-4-4-带-Cache-的-DRAM（CDRAM）"><a href="#7-4-4-带-Cache-的-DRAM（CDRAM）" class="headerlink" title="7.4.4 带 Cache 的 DRAM（CDRAM）"></a>7.4.4 带 Cache 的 DRAM（CDRAM）</h4><ul>
<li><strong>技术思路</strong>：在 DRAM 芯片内部集成一个小容量高速 SRAM 作为 Cache（通常为 1KB-16KB），利用 Cache 缓解 DRAM 的 “行激活延迟”，提升数据访问速度，尤其优化 “猝发式读取”（连续读取同一行内的数据）。</li>
<li><strong>核心工作机制</strong>：<ul>
<li><strong>行缓存机制</strong>：当 DRAM 读取某一行数据时，先将整行数据（通常为 512B 或 1024B）调入内部 SRAM Cache；后续若访问该行内的其他列数据，直接从 SRAM Cache 读取，无需重新进行行激活操作（行激活延迟约为 50ns，而 SRAM 读取延迟仅 5-10ns）。</li>
<li><strong>Cache 替换策略</strong>：采用简单的 “最近最少使用（LRU）” 或 “先进先出（FIFO）” 策略，当新行数据需调入 Cache 且 Cache 满时，替换掉最久未使用的行数据。</li>
</ul>
</li>
<li><strong>性能优势</strong>：<ul>
<li>针对连续数据访问（如读取指令流、数组），速度提升显著，猝发读取速率可接近 SRAM 水平。</li>
<li>无需修改外部硬件（如内存控制器），兼容性与传统 DRAM 一致，成本仅略高于普通 DRAM。</li>
</ul>
</li>
<li><strong>应用场景</strong>：20 世纪 90 年代末的部分高端 DRAM 芯片，如 Mitsubishi CDRAM、Toshiba CDRAM，主要应用于需要高猝发读取性能的设备（如激光打印机、高端显卡），随着 DDR SDRAM 技术的成熟，其优势逐渐被掩盖，应用范围缩小。</li>
</ul>
<h2 id="八、存储系统的性能评估与优化案例"><a href="#八、存储系统的性能评估与优化案例" class="headerlink" title="八、存储系统的性能评估与优化案例"></a>八、存储系统的性能评估与优化案例</h2><h3 id="8-1-存储系统性能评估指标"><a href="#8-1-存储系统性能评估指标" class="headerlink" title="8.1 存储系统性能评估指标"></a>8.1 存储系统性能评估指标</h3><p>除了前文提到的存储容量、存取速度、带宽，评估存储系统整体性能还需关注以下核心指标，这些指标直接反映存储系统与 CPU 的协同效率：</p>
<h4 id="8-1-1-Cache-命中率（H）"><a href="#8-1-1-Cache-命中率（H）" class="headerlink" title="8.1.1 Cache 命中率（H）"></a>8.1.1 Cache 命中率（H）</h4><ul>
<li><p><strong>定义</strong>：CPU 访问存储器时，命中 Cache 的次数占总访问次数的比例，即H = Cache 命中次数 / (Cache 命中次数 + Cache 缺失次数)</p>
</li>
<li><p>影响因素：</p>
<ul>
<li>Cache 容量：容量越大，可存储的数据块越多，命中率越高（但超过一定容量后，命中率提升趋于平缓）。</li>
<li>块大小：块越大，包含的连续数据越多，空间局部性利用越充分，但块过大可能导致 “块冲突”（同一 Cache 块替换频率增加），命中率反而下降，常见块大小为 32B、64B、128B。</li>
<li>映射方式：全相联映射命中率最高，直接映射最低，组相联映射介于两者之间（组相联度越高，命中率越接近全相联）。</li>
<li>替换算法：LRU 算法命中率高于 FIFO、LFU 算法，因更契合程序局部性原理。</li>
</ul>
</li>
<li><p><strong>工程经验</strong>：L1 Cache 容量通常为 32KB-256KB，命中率约 80%-95%；L2 Cache 容量为 256KB-8MB，命中率约 95%-99%；L3 Cache 容量为 8MB-128MB（服务器），命中率可达 99% 以上。</p>
</li>
</ul>
<h4 id="8-1-2-平均存取时间（Tavg）"><a href="#8-1-2-平均存取时间（Tavg）" class="headerlink" title="8.1.2 平均存取时间（Tavg）"></a>8.1.2 平均存取时间（T<sub>avg</sub>）</h4><ul>
<li><p>T<sub>avg</sub> = H × T<sub>c</sub> + (1 - H) × (T<sub>c</sub> + T<sub>m</sub>)，其中：</p>
</li>
<li><p>T<sub>c</sub>：Cache 存取时间。</p>
<ul>
<li>T<sub>m</sub>：主存存取时间（Cache 缺失时，需从主存读取数据块到 Cache，额外消耗 T<sub>m</sub> 时间）。</li>
</ul>
</li>
<li><p><strong>示例计算</strong>：假设 T<sub>c</sub> = 5ns，T<sub>m</sub> = 100ns，H = 95%，则T<sub>avg</sub>= 0.95 × 5 + 0.05 × (5 + 100) = 4.75 + 5.25 = 10ns，远低于主存的 100ns，充分体现 Cache 的加速作用。</p>
</li>
</ul>
<h4 id="8-1-3-存储器带宽（B）"><a href="#8-1-3-存储器带宽（B）" class="headerlink" title="8.1.3 存储器带宽（B）"></a>8.1.3 存储器带宽（B）</h4><ul>
<li><p>定义：单位时间内存储器可传输的数据总量，分为 “峰值带宽” 和 “实际带宽”：</p>
<ul>
<li>峰值带宽：理想情况下的最大带宽，计算公式为 <strong>B<sub>peak</sub> = (数据总线宽度 × 数据传输频率) / 8</strong>（单位：MB/s 或 GB/s）。例如，DDR4-3200 内存：<ul>
<li>数据总线宽度：64 位</li>
<li>数据传输频率：3200MHz</li>
<li>峰值带宽计算：(64 × 3200) / 8 = 25600MB/s = 25.6GB/s</li>
</ul>
</li>
<li>实际带宽：实际应用中，受地址传输、Cache 缺失、总线竞争等因素影响，实际带宽通常为峰值带宽的 30%-70%，需通过 benchmarks（如 MemTest、STREAM）测试。</li>
</ul>
</li>
</ul>
<h3 id="8-2-存储系统优化案例（以-PC-主机为例）"><a href="#8-2-存储系统优化案例（以-PC-主机为例）" class="headerlink" title="8.2 存储系统优化案例（以 PC 主机为例）"></a>8.2 存储系统优化案例（以 PC 主机为例）</h3><h4 id="8-2-1-消费级-PC-存储系统优化（兼顾成本与性能）"><a href="#8-2-1-消费级-PC-存储系统优化（兼顾成本与性能）" class="headerlink" title="8.2.1 消费级 PC 存储系统优化（兼顾成本与性能）"></a>8.2.1 消费级 PC 存储系统优化（兼顾成本与性能）</h4><ul>
<li><p>Cache 设计：</p>
<ul>
<li>L1 Cache：分指令 Cache（I-Cache）和数据 Cache（D-Cache），容量各 32KB-64KB，采用 8 路组相联映射，块大小 64B，写回策略（减少主存写延迟）。</li>
<li>L2 Cache：容量 256KB-2MB，集成于 CPU 内核中，采用 16 路组相联映射，块大小 64B，与 L1 Cache 共享替换算法和写策略。</li>
<li>L3 Cache：容量 8MB-64MB，共享于多个 CPU 内核，采用 24 路 - 48 路组相联映射，块大小 64B-128B，缓解多内核间的数据共享延迟。</li>
</ul>
</li>
<li><p>主存设计：</p>
<ul>
<li>采用 DDR4/DDR5 SDRAM，双通道配置（如 2×8GB DDR4-3200），提升带宽（双通道 DDR4-3200 峰值带宽达 51.2GB/s）。</li>
<li>内存时序优化：调整 CAS Latency（CL，列地址选通延迟）、RAS to CAS Delay（tRCD，行到列延迟）等参数，如将 CL 从 18 降至 16，减少实际存取延迟（需在稳定性和延迟间平衡）。</li>
</ul>
</li>
<li><p>外存搭配：</p>
<ul>
<li>采用 “SSD + HDD” 混合存储：SSD（如 NVMe M.2 SSD，读取速度 3000MB/s-7000MB/s）用于安装操作系统和常用软件，HDD（读取速度 100MB/s-200MB/s）用于存储大容量文件（如视频、文档），兼顾速度和容量。</li>
</ul>
</li>
</ul>
<h4 id="8-2-2-服务器存储系统优化（侧重高带宽与可靠性）"><a href="#8-2-2-服务器存储系统优化（侧重高带宽与可靠性）" class="headerlink" title="8.2.2 服务器存储系统优化（侧重高带宽与可靠性）"></a>8.2.2 服务器存储系统优化（侧重高带宽与可靠性）</h4><ul>
<li><p>Cache 设计：</p>
<ul>
<li>L3 Cache 容量大幅提升（32MB-128MB），支持 “包容性 Cache”（L1/L2 Cache 中的数据均存在于 L3 Cache 中），减少多内核间的数据一致性维护成本。</li>
<li>引入 “预取器”（Prefetcher）：通过硬件预测 CPU 即将访问的数据（如按地址递增预取、按指令流预取），提前将数据从主存调入 Cache，进一步提升命中率（预取准确率通常达 70%-80%）。</li>
</ul>
</li>
<li><p>主存设计：</p>
<ul>
<li>多通道内存配置：服务器主板通常支持 4 通道、8 通道甚至 16 通道内存，如 8 通道 DDR5-4800 内存，峰值带宽达 8 x ((64 x 800) / 8)= 307200MB/s = 307.2GB/s)，满足多线程、大数据量计算需求（如数据库、AI 训练）。</li>
<li>内存容错技术：支持 ECC（Error-Correcting Code，错误纠正码）内存，通过额外的校验位检测并纠正 1 位错误，检测 2 位错误，避免内存错误导致系统崩溃（服务器核心需求）。</li>
</ul>
</li>
<li><p>外存设计：</p>
<ul>
<li>采用 RAID（独立磁盘冗余阵列）技术：将多块 SSD/HDD 组成 RAID 0（条带化，提升带宽）、RAID 1（镜像，提升可靠性）、RAID 5（条带化 + 分布式校验，兼顾带宽和可靠性）或 RAID 10（RAID 1+RAID 0，高带宽 + 高可靠性），满足不同业务场景需求。</li>
</ul>
</li>
<li><p>引入存储级内存（SCM）：如 Intel Optane，兼具 DRAM 的速度（读取延迟～100ns）和 SSD 的非易失性，作为 “内存扩展层” 或 “高速缓存层”，进一步缩小主存与外存的速度差距。</p>
</li>
</ul>
<h2 id="九、存储系统的发展趋势"><a href="#九、存储系统的发展趋势" class="headerlink" title="九、存储系统的发展趋势"></a>九、存储系统的发展趋势</h2><p>随着大数据、人工智能、云计算等技术的爆发，存储系统面临 “更高速度、更大容量、更低延迟、更低功耗” 的需求，未来将向以下方向发展：</p>
<h3 id="9-1-非易失性存储器（NVM）的普及与架构革新"><a href="#9-1-非易失性存储器（NVM）的普及与架构革新" class="headerlink" title="9.1 非易失性存储器（NVM）的普及与架构革新"></a>9.1 非易失性存储器（NVM）的普及与架构革新</h3><ul>
<li><p>技术突破：传统存储层次（Cache - 主存 - 外存）的界限将被打破，非易失性存储器（如相变存储器 PCRAM、阻变存储器 RRAM、铁电存储器 FeRAM）将逐步替代部分 DRAM 和 SSD：</p>
<ul>
<li>PCRAM：利用材料相变（晶态 / 非晶态）存储信息，读写速度接近 DRAM（~10ns），非易失性，寿命达 10<sup>6</sup>-10<sup>8</sup> 次，适合作为 “持久化内存”（Persistent Memory）。</li>
<li>RRAM：利用材料电阻变化存储信息，读写速度快（~1ns），集成度高（可 3D 堆叠），功耗低，适合作为 L2/L3 Cache 或主存。</li>
</ul>
</li>
<li><p>架构革新：</p>
<ul>
<li>“内存 - 存储融合”：NVM 作为主存时，数据断电不丢失，无需将数据回写外存，大幅减少 I/O 延迟，适合数据库、AI 训练等需要频繁访问海量数据的场景。</li>
</ul>
</li>
<li><p>“Cache-NVM 融合”：在 CPU 内部集成 NVM Cache，替代部分 SRAM Cache，降低成本和功耗（SRAM 功耗是 NVM 的 5-10 倍），同时保持较高速度。</p>
</li>
</ul>
<h3 id="9-2-3D-堆叠存储技术的规模化应用"><a href="#9-2-3D-堆叠存储技术的规模化应用" class="headerlink" title="9.2 3D 堆叠存储技术的规模化应用"></a>9.2 3D 堆叠存储技术的规模化应用</h3><ul>
<li><p><strong>技术思路</strong>：通过 “垂直堆叠” 存储芯片，在有限的芯片面积内提升存储容量，同时缩短芯片间数据传输路径，降低延迟、提升带宽。传统 2D 存储芯片仅在平面上集成存储单元，而 3D 堆叠技术通过硅通孔（TSV，Through-Silicon Via）、微凸点（Micro-Bump）等互连技术，将多层存储芯片（或存储芯片与逻辑芯片）垂直堆叠，形成 “3D 存储模块”。</p>
</li>
<li><p>核心优势：</p>
<ul>
<li><strong>容量密度提升</strong>：以 3D NAND Flash 为例，传统 2D NAND 受限于平面工艺，单芯片容量难以突破 1TB；3D NAND 通过堆叠 100 层以上的存储单元（如三星 V-NAND 已实现 512 层堆叠），单芯片容量可达 4TB-16TB，且成本随堆叠层数增加而降低。</li>
<li><strong>速度与功耗优化</strong>：3D 堆叠缩短了数据传输路径（传统 2D 芯片间数据需通过外部总线传输，3D 堆叠通过 TSV 直接垂直传输），数据传输延迟降低 50% 以上，带宽提升 3-5 倍；同时，垂直互连减少了信号衰减，功耗降低 30%-40%。</li>
<li><strong>异构集成能力</strong>：可将存储芯片与逻辑芯片（如内存控制器、Cache、预处理电路）垂直堆叠，形成 “存储 - 计算一体化” 模块。例如，将 3D DRAM 与 AI 计算核心堆叠，AI 核心可直接访问堆叠的 DRAM，避免外部总线瓶颈，提升 AI 推理 / 训练速度。</li>
</ul>
</li>
<li><p>应用场景：</p>
<ul>
<li><strong>消费级存储</strong>：3D NAND 已成为 SSD 的主流技术，如三星 990 Pro、西部数据 SN850X 等高端 SSD 均采用 3D NAND，容量可达 4TB-8TB，读取速度突破 7000MB/s。</li>
<li><strong>服务器与数据中心</strong>：3D 堆叠 DRAM（如美光 HBM3、三星 HBM3E）作为 “高带宽内存”（HBM），专为 GPU、AI 加速卡设计，单模块容量达 64GB-128GB，带宽达 1TB/s 以上，满足 AI 训练对海量数据高速访问的需求。</li>
<li><strong>移动设备</strong>：3D 堆叠 eMMC、UFS 芯片（如三星 3D eMMC），在小体积内实现大存储容量（如 1TB），同时降低功耗，延长手机、平板的续航时间。</li>
</ul>
</li>
</ul>
<h3 id="9-3-存储级内存（SCM）的产业化落地"><a href="#9-3-存储级内存（SCM）的产业化落地" class="headerlink" title="9.3 存储级内存（SCM）的产业化落地"></a>9.3 存储级内存（SCM）的产业化落地</h3><ul>
<li><p><strong>技术定位</strong>：存储级内存（Storage-Class Memory）是介于主存（DRAM）和外存（SSD/HDD）之间的 “新型存储层级”，兼具 DRAM 的高速（读取延迟～100ns，接近 DRAM 的～50ns）、高带宽和 SSD 的非易失性、大容量，填补传统存储层次的速度鸿沟。</p>
</li>
<li><p>主流技术类型：</p>
<ul>
<li><strong>Intel Optane（基于 3D XPoint 技术）</strong>：通过 “相变材料 + 交叉点架构” 存储信息，读写速度是传统 SSD 的 5-10 倍（读取延迟～100ns，写入延迟～300ns），寿命达 10^6 次以上，支持字节级访问（传统 SSD 需按页访问），可作为 “持久化内存”（PMem）直接替代部分 DRAM。</li>
<li><strong>MRAM（磁阻随机存取存储器）</strong>：利用磁隧道结（MTJ）的电阻变化存储信息，读写速度达～10ns（接近 SRAM），非易失性，寿命无限（无写入磨损），功耗低，适合作为 CPU 的 L2/L3 Cache 或嵌入式系统的主存。</li>
<li><strong>FeRAM（铁电随机存取存储器）</strong>：利用铁电材料的极化特性存储信息，读写速度～10ns，非易失性，功耗仅为 SRAM 的 1/10，适合低功耗场景（如物联网传感器、可穿戴设备）。</li>
</ul>
</li>
<li><p>应用模式：</p>
<ul>
<li><strong>内存扩展模式</strong>：将 SCM 作为 DRAM 的扩展，当 DRAM 容量不足时，CPU 可直接访问 SCM 中的数据（无需通过外存 I/O 协议），如 Intel Optane 以 “App Direct Mode” 运行，为数据库、虚拟化等应用提供大容量高速内存。</li>
</ul>
</li>
<li><p><strong>缓存加速模式</strong>：将 SCM 作为 SSD 的缓存层，频繁访问的数据暂存于 SCM 中，减少 SSD 的读写次数，提升整体存储速度。例如，数据中心存储阵列中，SCM 缓存层可将随机读写延迟从 SSD 的～1ms 降至～100ns，带宽提升 10 倍以上。</p>
</li>
</ul>
<h3 id="9-4-存储-计算一体化（In-Memory-Computing-Storage-Class-Computing）"><a href="#9-4-存储-计算一体化（In-Memory-Computing-Storage-Class-Computing）" class="headerlink" title="9.4 存储 - 计算一体化（In-Memory Computing/Storage-Class Computing）"></a>9.4 存储 - 计算一体化（In-Memory Computing/Storage-Class Computing）</h3><ul>
<li><p><strong>技术背景</strong>：传统计算机采用 “冯・诺依曼架构”，存储与计算分离，数据需在 CPU（计算单元）和存储器（存储单元）之间频繁传输，导致 “存储墙” 问题 —— 数据传输延迟远高于计算延迟（如 CPU 完成一次加法运算仅需 1ns，而从主存读取数据需 50ns，从 SSD 读取需 1ms），尤其在 AI、大数据分析等数据密集型应用中，“存储墙” 成为性能瓶颈。</p>
</li>
<li><p><strong>核心思路</strong>：将计算能力嵌入存储单元或存储模块中，让数据 “就地计算”，减少数据传输量和传输延迟，实现 “存储 - 计算一体化”。</p>
</li>
<li><p>主流实现方式：</p>
<ul>
<li><strong>存内计算（In-Memory Computing, IMC）</strong>：在 DRAM 或 NVM 存储单元内部集成简单计算电路（如加法器、比较器），直接对存储单元中的数据进行计算。例如，在 AI 推理中，神经网络的权重数据存储在 IMC 存储器中，输入数据与权重的乘法 - 累加（MAC）运算直接在存储单元内完成，无需将数据传输到 CPU/GPU，运算延迟降低 100 倍以上，功耗降低 1000 倍以上。</li>
<li><strong>存算一体芯片（Storage-Compute Chip）</strong>：将存储阵列与专用计算核心（如 RISC-V 内核、AI 加速器）集成在同一芯片上，通过高速内部总线连接，形成 “片上存储 - 计算系统”。例如，英伟达 Grace 芯片将 ARM 计算核心与 HBM3 内存集成，专为大数据和 AI workload 设计，内存带宽达 3.3TB/s，数据传输延迟远低于传统 “CPU + 外置内存” 架构。</li>
<li><strong>近存储计算（Near-Storage Computing, NSC）</strong>：在存储设备（如 SSD、存储服务器）中集成计算单元（如 FPGA、ASIC），对存储设备中的数据进行预处理（如过滤、排序、压缩），仅将处理后的结果传输到 CPU，减少数据传输量。例如，数据中心存储阵列中的 NSC 单元可提前对海量日志数据进行过滤和聚合，将传输到服务器的数据量减少 90%，大幅提升数据分析效率。</li>
</ul>
</li>
<li><p>应用场景：</p>
<ul>
<li><strong>AI 推理与训练</strong>：存内计算芯片可高效处理神经网络的 MAC 运算，适合边缘 AI 设备（如摄像头、传感器）和数据中心 AI 服务器。</li>
<li><strong>大数据分析</strong>：近存储计算可在存储端完成数据预处理，提升 Hadoop、Spark 等大数据框架的运行效率。</li>
<li><strong>物联网（IoT）</strong>：低功耗存算一体芯片可嵌入 IoT 传感器，实现数据的本地采集、计算和传输，减少对云端的依赖，降低网络带宽和功耗。</li>
</ul>
</li>
</ul>
<h3 id="9-5-存储系统的智能化与自优化"><a href="#9-5-存储系统的智能化与自优化" class="headerlink" title="9.5 存储系统的智能化与自优化"></a>9.5 存储系统的智能化与自优化</h3><ul>
<li><p><strong>技术方向</strong>：随着存储系统规模扩大（如数据中心存储容量达 EB 级）和应用场景复杂化，传统 “人工配置 + 固定策略” 的管理方式已无法满足需求，存储系统将向 “智能化” 发展，通过 AI / 机器学习算法实现自监控、自诊断、自优化。</p>
</li>
<li><p>核心能力：</p>
<ul>
<li><strong>智能缓存与数据布局</strong>：通过机器学习算法分析历史访问数据（如访问频率、访问模式、数据生命周期），动态调整缓存策略（如 LRU 算法的参数优化、缓存块大小自适应）和数据布局（如将高频访问数据迁移到高速存储层，低频数据迁移到低速存储层）。例如，华为 OceanStor 存储系统采用 “智能数据分层” 技术，基于 AI 预测数据访问热度，自动将数据在 SSD、SAS HDD、SATA HDD 之间迁移，存储效率提升 30% 以上。</li>
<li><strong>智能故障预测与自愈</strong>：通过传感器实时监控存储硬件（如硬盘、内存、电源）的运行状态（如温度、电压、读写错误率），结合机器学习模型预测硬件故障（预测准确率达 90% 以上），提前触发数据迁移和硬件更换；同时，对软件层面的错误（如数据一致性错误、协议异常）进行自动检测和修复，提升存储系统的可靠性。</li>
<li><strong>智能能耗管理</strong>：通过 AI 算法分析存储系统的负载变化（如白天高负载、夜间低负载），动态调整存储节点的供电状态（如低负载时关闭部分存储体、降低总线频率）和风扇转速，在保证性能的前提下降低能耗。例如，谷歌数据中心的存储系统通过智能能耗管理，每年减少 15%-20% 的电力消耗。</li>
</ul>
</li>
<li><p><strong>技术支撑</strong>：存储系统智能化需依赖 “存储大数据”（如访问日志、性能指标、故障记录）的采集与分析，以及边缘计算（本地实时分析）和云计算（全局优化）的协同 —— 边缘节点负责实时数据采集和本地优化，云端负责全局数据聚合、模型训练和策略更新，形成 “边缘 - 云端” 协同的智能存储管理体系。</p>
</li>
</ul>
<h2 id="十、总结与展望"><a href="#十、总结与展望" class="headerlink" title="十、总结与展望"></a>十、总结与展望</h2><h3 id="10-1-核心知识总结"><a href="#10-1-核心知识总结" class="headerlink" title="10.1 核心知识总结"></a>10.1 核心知识总结</h3><p>本文从存储系统的基础认知出发，系统梳理了存储系统的层次架构、核心组件（主存、RAM、ROM、Cache）、关键技术（存储器连接、校验、访存速度优化）及发展趋势，核心要点可归纳为以下四方面：</p>
<ol>
<li><strong>层次架构是平衡性能与成本的核心</strong>：存储系统通过 “寄存器 - Cache - 主存 - 外存” 的层次结构，在速度（寄存器最快，外存最慢）、容量（外存最大，寄存器最小）、成本（外存最低，寄存器最高）之间取得平衡，其中 Cache - 主存层次是解决 CPU - 主存速度差的关键，主存 - 外存层次是解决容量与成本矛盾的关键。</li>
<li><strong>核心组件各有定位与技术特性</strong>：<ul>
<li>RAM 分为 SRAM（高速、低容量、高成本，用于 Cache）和 DRAM（低速、大容量、低成本，用于主存），DRAM 技术通过 SDRAM→DDR→DDR5 的迭代不断提升速度与带宽；</li>
<li>ROM 是非易失性存储，从掩模 ROM 到 Flash Memory 的演进，满足了固定程序存储（如 BIOS）和大容量非易失性存储（如 SSD）的需求；</li>
<li>Cache 依赖 “程序局部性原理”，通过直接映射 / 全相联 / 组相联映射、写直达 / 写回策略，实现高命中率，大幅缩短 CPU 访存延迟。</li>
</ul>
</li>
<li><strong>关键技术保障存储系统的可靠性与效率</strong>：<ul>
<li>存储器连接技术（位扩展、字扩展、字位同时扩展）解决了单芯片容量不足的问题，片选控制（线选法、译码法）确保多芯片的有序协作；</li>
<li>校验技术（奇偶校验、汉明码、CRC）通过添加冗余位，实现数据错误的检测与纠正，其中汉明码可纠正 1 位错误，CRC 检错能力强，广泛应用于通信与存储；</li>
<li>访存速度优化措施从 “器件 - 结构 - 算法” 多维度发力：高速器件（SDRAM、DDR）提升硬件速度，Cache - 主存层次和多体并行结构（低位交叉编址）利用并行性提升效率，预取算法和智能缓存策略进一步优化访问延迟。</li>
</ul>
</li>
<li><strong>发展趋势聚焦 “突破瓶颈、融合创新”</strong>：存储系统正朝着 “非易失性化”（NVM 打破存储层次界限）、“3D 堆叠化”（提升容量与带宽）、“存算一体化”（解决存储墙问题）、“智能化”（自优化与自管理）方向发展，这些趋势的核心目标是突破传统存储系统的速度、容量、功耗瓶颈，满足大数据、AI、云计算等新兴应用的需求。</li>
</ol>
<h3 id="10-2-未来展望"><a href="#10-2-未来展望" class="headerlink" title="10.2 未来展望"></a>10.2 未来展望</h3><p>随着计算机技术的不断演进，存储系统将面临更严峻的挑战（如 CPU 主频突破 10GHz 后，存储速度需进一步提升；AI 训练数据量达 PB 级，存储容量需持续扩容），但也将迎来更多创新机遇：</p>
<ul>
<li><strong>技术层面</strong>：非易失性存储器（如 PCRAM、RRAM）的成熟将可能替代 DRAM 成为主存，实现 “持久化内存”，彻底改变传统存储层次；3D 堆叠技术与存算一体化的结合，将催生 “片上存储 - 计算系统”，让数据无需跨芯片传输即可完成计算，大幅提升数据密集型应用的性能。</li>
<li><strong>应用层面</strong>：在边缘计算场景（如 IoT 传感器、自动驾驶），低功耗、小体积、高可靠性的存储系统（如 FeRAM、MRAM）将成为主流；在数据中心场景，“智能存储 + AI” 的融合将实现存储系统的全自动管理，无需人工干预即可应对负载变化、故障修复和能耗优化；在量子计算场景，量子存储技术（如量子点存储、光量子存储）的突破将为量子计算机提供大容量、高保真的量子态存储，推动量子计算的实用化。</li>
<li><strong>产业层面</strong>：存储系统将从 “单一硬件产品” 向 “硬件 + 软件 + 服务” 的一体化解决方案转变，例如，存储厂商不仅提供存储硬件，还将提供基于 AI 的存储管理软件、数据备份与恢复服务、存储安全服务等，形成 “端到端” 的存储服务体系。同时，存储系统的标准化（如 NVM Express 协议、CXL 互连协议）将进一步加强，促进不同厂商产品的兼容性，降低用户的部署与维护成本。</li>
</ul>
<p>总之，存储系统作为计算机体系的 “数据基石”，其技术演进将始终与应用需求同频共振，在突破瓶颈、融合创新的过程中，持续为计算机技术的发展提供支撑，成为数字经济时代不可或缺的核心基础设施。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://lvjia.netlify.app">lvting.chi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://lvjia.netlify.app/6-ji-suan-ji-zu-cheng-yuan-li-shen-ru-xue-xi-cun-chu-xi-tong/">http://lvjia.netlify.app/6-ji-suan-ji-zu-cheng-yuan-li-shen-ru-xue-xi-cun-chu-xi-tong/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://lvjia.netlify.app" target="_blank">Lvjia</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/7-ji-suan-ji-zu-cheng-yuan-li-shen-ru-li-jie-gao-su-huan-chong-cun-chu-qi-cache/" title="7、计算机组成原理: 深入理解高速缓冲存储器（Cache)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">7、计算机组成原理: 深入理解高速缓冲存储器（Cache)</div></div><div class="info-2"><div class="info-item-1">深入理解计算机高速缓冲存储器（Cache）前言：为什么需要 Cache？在计算机系统中，CPU 的速度与主存储器（DRAM）的速度之间存在着数量级的差距。这种差距导致 CPU 在等待主存数据时会出现大量的 “空等” 现象，严重制约了整个计算机系统的性能。为了解决这一问题，高速缓冲存储器（Cache）应运而生。 Cache 是一种速度极快、容量较小的存储器，位于 CPU 和主存之间。它利用程序访问的局部性原理（即程序在执行时，短期内会重复访问某些指令或数据），将 CPU 近期可能访问的指令和数据预先缓存起来，从而减少 CPU 对主存的直接访问，大幅提升系统性能。 一、Cache 概述1.1 问题的提出现代 CPU 的时钟频率已经达到 GHz 级别，而主存（DRAM）的访问速度通常在几十到几百个时钟周期之间。假设 CPU 需要从主存中读取一个数据，主存需要 100 个时钟周期才能返回数据，而在这 100 个时钟周期内，CPU 只能处于等待状态，这无疑是对计算资源的巨大浪费。 为了避免这种 “空等” 现象，我们需要在 CPU 和主存之间设置一个速度接近 CPU 的存储器，这就是 Cac...</div></div></div></a><a class="pagination-related" href="/5-ji-suan-ji-zu-cheng-yuan-li-cun-chu-qi-yuan-li-fen-xi/" title="5、计算机组成原理: 存储器原理分析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">5、计算机组成原理: 存储器原理分析</div></div><div class="info-2"><div class="info-item-1">5、计算机组成原理: 存储器原理分析引言在计算机系统的复杂架构中，存储器扮演着极为关键的角色，它是数据与程序的 “栖息地”，支撑着计算机从简单的指令执行到复杂的多任务处理。深入探究存储器的分类、层次结构，不仅有助于理解计算机高效运行的底层逻辑，更能为硬件设计优化、软件性能调优筑牢理论根基。接下来，我们将全方位、深层次地剖析计算机存储器体系。 一、存储器分类全解（一）按存储介质分类存储介质作为存储器的 “物质基础”，直接决定了其存储原理与特性，主要有以下几类：  半导体存储器 技术基础：依托半导体器件构建存储单元，常见的有 TTL（晶体管 - 晶体管逻辑）和 MOS（金属 - 氧化物 - 半导体）技术。TTL 速度较快，但功耗高；MOS 功耗低、集成度高，是现代半导体存储器的主流技术。 易失性特质：所谓 “易失”，指的是一旦断电，存储的信息便会丢失。这是因为其存储依赖于半导体器件的电状态，断电后电状态无法维持。像计算机的内存（RAM），就多采用半导体存储，系统运行时临时数据存于此处，关机重启后需重新加载。   磁表面存储器 核心部件：由磁头和载磁体（如硬盘的盘片、磁带等）构成。磁头...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/1-ji-suan-ji-zu-cheng-yuan-li-liao-jie-di-ceng-luo-ji/" title="1、计算机组成原理-了解底层逻辑"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-27</div><div class="info-item-2">1、计算机组成原理-了解底层逻辑</div></div><div class="info-2"><div class="info-item-1">1、计算机组成原理-了解底层逻辑一、引言计算机组成原理，作为计算机专业基石课程，搭建起从硬件电路到软件运行的理解桥梁。初次接触其知识体系，恰似打开神秘黑箱，看清内部精密协作的齿轮，知晓程序如何在硬件舞台上 “翩翩起舞”，理解计算机系统如何高效运转。本文从程序执行流程、计算机硬件结构、指令系统、体系结构设计等维度，深入探寻计算机组成原理的奥秘，为后续深入学习筑牢根基。 二、程序执行：指令的 “生命旅程”（一）从高级语言到机器指令当我们在编程时写下z = x + y这样简洁的高级语言表达式，计算机无法直接理解。高级语言需经过编译或解释过程，转化为机器指令序列，这是计算机能识别并执行的 “母语”。机器指令由 0 和 1 组成的二进制代码构成，对应着计算机硬件可直接操作的基本动作。 （二）指令执行的 “三步走”程序执行核心流程可概括为取指令、分析指令（解码）、执行指令，循环往复直至程序结束，时钟信号如同精准的 “节拍器”，驱动每一步有序推进。  取指令：CPU 从存储器中指定位置（由程序计数器 PC 指向）读取指令。比如执行z = x + y，首先要获取LOAD X指令，此时存储器需准确...</div></div></div></a><a class="pagination-related" href="/2-ji-suan-ji-zu-cheng-yuan-li-gai-shu/" title="2、计算机组成原理：概述"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-30</div><div class="info-item-2">2、计算机组成原理：概述</div></div><div class="info-2"><div class="info-item-1">2、计算机组成原理：概述一、引言计算机组成原理是计算机科学与技术领域的核心课程，它搭建起了从硬件底层到软件应用的桥梁。对于初学者而言，这是打开计算机世界大门的钥匙，能让他们明白日常使用的软件是如何在硬件上运行的；对于有经验的开发者或工程师来说，深入理解计算机组成原理，有助于在系统优化、性能调优等方面获得突破，能从底层逻辑去思考和解决问题。接下来，我们将从计算机系统的整体认知开始，逐步深入到各个核心组件和技术原理，带领大家全面探索计算机组成的奥秘。 二、计算机系统整体认识（一）层次结构计算机系统是一个多层次的结构，从最底层的硬件到最上层的应用软件，每一层都构建在其下一层的基础之上，并且每一层都为上一层提供服务。我们可以将其大致分为以下几个层次（从下到上）： 微程序机器 M₀ ────────────────────── 微指令系统实际机器 M₁ ──────────────────────── 机器语言虚拟机器 ────────────────────────── 操作系统虚拟机器 M₂ ──────────────────────── 汇编语言虚拟机器 M₃ ──────────...</div></div></div></a><a class="pagination-related" href="/3-ji-suan-ji-zu-cheng-yuan-li-zong-xian-gai-shu/" title="3、计算机组成原理: 总线概述"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-01</div><div class="info-item-2">3、计算机组成原理: 总线概述</div></div><div class="info-2"><div class="info-item-1">3、计算机组成原理: 总线概述引言在计算机组成原理的知识体系中，总线是连接计算机各个功能部件的关键纽带，如同城市里的交通网络，支撑着数据、指令与控制信号的高效传输。无论是初学者初识计算机内部架构，还是有经验的开发者深入优化系统性能，理解总线的工作机制、分类特性与标准规范，都有着至关重要的意义。 从第一台电子计算机 ENIAC 的庞杂布线，到现代智能手机芯片内部的纳米级总线，总线技术的演进直接推动了计算机性能的飞跃。ENIAC 没有真正意义上的总线，部件间通过数千根导线点对点连接，修改程序需重新布线，效率极低；而如今的超级计算机，通过高速总线将数万颗处理器、PB 级内存与海量存储设备连接，实现每秒亿亿次的运算能力。这种跨越背后，是总线从 “物理连线” 到 “智能交互系统” 的蜕变。 本系列将结合哈工大计算机组成原理课程内容，从基础概念到实际应用，从经典标准到前沿趋势，全方位剖析总线系统。通过字符图、案例分析、工程实践等多元形式，助力初学者构建完整知识框架，为资深从业者提供深度技术参考，最终让读者理解：总线不仅是 “连接线”，更是计算机系统协同运作的 “神经中枢”。 一、总线基础概念...</div></div></div></a><a class="pagination-related" href="/4-ji-suan-ji-zu-cheng-yuan-li-tan-suo-zong-xian-yan-jin-guo-cheng/" title="4、计算机组成原理: 探索总线演进过程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-03</div><div class="info-item-2">4、计算机组成原理: 探索总线演进过程</div></div><div class="info-2"><div class="info-item-1">4、计算机组成原理: 探索总线演进过程一、引言在计算机系统的庞大体系中，总线如同人体的 “神经网络”，承担着各部件间数据、地址与控制信号传输的关键任务。从早期结构简单的单总线，到如今复杂且高效的多层 PCI 总线，总线结构的每一次演进，都紧密契合着计算机性能提升与应用场景拓展的需求。本文将以时间为脉络，深度剖析各类总线结构的原理、特性及应用，带读者领略计算机总线技术发展的壮丽图景。 二、单总线结构：计算机总线的起点2.1 结构与组成单总线结构是计算机总线发展的初始形态，其核心是一条系统总线，将 CPU、主存以及各类 I/O 设备（通过 I/O 接口连接）全部连接起来。用文字符号构建的示意框图如下：CPU &lt;-&gt; 系统总线 &lt;-&gt; 主存系统总线 &lt;-&gt; I/O接口1 &lt;-&gt; I/O设备1系统总线 &lt;-&gt; I/O接口2 &lt;-&gt; I/O设备2...系统总线 &lt;-&gt; I/O接口n &lt;-&gt; I/O设备n 2.2 工作原理在单总线结构中，所有部件共享同一条系统总线。当 CPU 需要与主存交换数据时...</div></div></div></a><a class="pagination-related" href="/5-ji-suan-ji-zu-cheng-yuan-li-cun-chu-qi-yuan-li-fen-xi/" title="5、计算机组成原理: 存储器原理分析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-04</div><div class="info-item-2">5、计算机组成原理: 存储器原理分析</div></div><div class="info-2"><div class="info-item-1">5、计算机组成原理: 存储器原理分析引言在计算机系统的复杂架构中，存储器扮演着极为关键的角色，它是数据与程序的 “栖息地”，支撑着计算机从简单的指令执行到复杂的多任务处理。深入探究存储器的分类、层次结构，不仅有助于理解计算机高效运行的底层逻辑，更能为硬件设计优化、软件性能调优筑牢理论根基。接下来，我们将全方位、深层次地剖析计算机存储器体系。 一、存储器分类全解（一）按存储介质分类存储介质作为存储器的 “物质基础”，直接决定了其存储原理与特性，主要有以下几类：  半导体存储器 技术基础：依托半导体器件构建存储单元，常见的有 TTL（晶体管 - 晶体管逻辑）和 MOS（金属 - 氧化物 - 半导体）技术。TTL 速度较快，但功耗高；MOS 功耗低、集成度高，是现代半导体存储器的主流技术。 易失性特质：所谓 “易失”，指的是一旦断电，存储的信息便会丢失。这是因为其存储依赖于半导体器件的电状态，断电后电状态无法维持。像计算机的内存（RAM），就多采用半导体存储，系统运行时临时数据存于此处，关机重启后需重新加载。   磁表面存储器 核心部件：由磁头和载磁体（如硬盘的盘片、磁带等）构成。磁头...</div></div></div></a><a class="pagination-related" href="/7-ji-suan-ji-zu-cheng-yuan-li-shen-ru-li-jie-gao-su-huan-chong-cun-chu-qi-cache/" title="7、计算机组成原理: 深入理解高速缓冲存储器（Cache)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-21</div><div class="info-item-2">7、计算机组成原理: 深入理解高速缓冲存储器（Cache)</div></div><div class="info-2"><div class="info-item-1">深入理解计算机高速缓冲存储器（Cache）前言：为什么需要 Cache？在计算机系统中，CPU 的速度与主存储器（DRAM）的速度之间存在着数量级的差距。这种差距导致 CPU 在等待主存数据时会出现大量的 “空等” 现象，严重制约了整个计算机系统的性能。为了解决这一问题，高速缓冲存储器（Cache）应运而生。 Cache 是一种速度极快、容量较小的存储器，位于 CPU 和主存之间。它利用程序访问的局部性原理（即程序在执行时，短期内会重复访问某些指令或数据），将 CPU 近期可能访问的指令和数据预先缓存起来，从而减少 CPU 对主存的直接访问，大幅提升系统性能。 一、Cache 概述1.1 问题的提出现代 CPU 的时钟频率已经达到 GHz 级别，而主存（DRAM）的访问速度通常在几十到几百个时钟周期之间。假设 CPU 需要从主存中读取一个数据，主存需要 100 个时钟周期才能返回数据，而在这 100 个时钟周期内，CPU 只能处于等待状态，这无疑是对计算资源的巨大浪费。 为了避免这种 “空等” 现象，我们需要在 CPU 和主存之间设置一个速度接近 CPU 的存储器，这就是 Cac...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">lvting.chi</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E5%85%A8%E8%A7%A3%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">计算机组成原理存储系统全解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E8%AE%A4%E7%9F%A5"><span class="toc-number">1.1.</span> <span class="toc-text">一、存储系统基础认知</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A0%B8%E5%BF%83%E5%9C%B0%E4%BD%8D"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 存储系统的核心地位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E6%9E%B6%E6%9E%84"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 存储系统的层次架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 存储系统性能指标</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90"><span class="toc-number">1.2.</span> <span class="toc-text">二、主存储器深度剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E4%B8%BB%E5%AD%98%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 主存的硬件组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83%E4%B8%8E%E5%9C%B0%E5%9D%80%E7%BC%96%E7%A0%81"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 存储单元与地址编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E4%B8%BB%E5%AD%98%E7%9A%84%E6%8A%80%E6%9C%AF%E6%8C%87%E6%A0%87%E7%BB%86%E5%8C%96"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 主存的技术指标细化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8%EF%BC%88RAM%EF%BC%89%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.3.</span> <span class="toc-text">三、随机存取存储器（RAM）详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E9%9D%99%E6%80%81-RAM%EF%BC%88SRAM%EF%BC%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 静态 RAM（SRAM）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">3.1.1 存储原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-%E7%89%B9%E7%82%B9%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">3.1.2 特点与应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%8A%A8%E6%80%81-RAM%EF%BC%88DRAM%EF%BC%89"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 动态 RAM（DRAM）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">3.2.1 存储原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E5%88%B7%E6%96%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">3.2.2 刷新方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-%E7%89%B9%E7%82%B9%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">3.2.3 特点与应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-SRAM-%E4%B8%8E-DRAM-%E5%85%A8%E9%9D%A2%E5%AF%B9%E6%AF%94"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 SRAM 与 DRAM 全面对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8%EF%BC%88ROM%EF%BC%89%E8%A7%A3%E6%9E%90"><span class="toc-number">1.4.</span> <span class="toc-text">四、只读存储器（ROM）解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%8E%A9%E6%A8%A1-ROM"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1 掩模 ROM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%8F%AF%E7%BC%96%E7%A8%8B-ROM%EF%BC%88PROM%EF%BC%89"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2 可编程 ROM（PROM）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%8F%AF%E6%93%A6%E9%99%A4%E5%8F%AF%E7%BC%96%E7%A8%8B-ROM%EF%BC%88EPROM%EF%BC%89"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3 可擦除可编程 ROM（EPROM）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E7%94%B5%E5%8F%AF%E6%93%A6%E9%99%A4%E5%8F%AF%E7%BC%96%E7%A8%8B-ROM%EF%BC%88EEPROM%EF%BC%89"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.4 电可擦除可编程 ROM（EEPROM）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-Flash-Memory%EF%BC%88%E9%97%AA%E5%AD%98%EF%BC%89"><span class="toc-number">1.4.5.</span> <span class="toc-text">4.5 Flash Memory（闪存）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%8E-CPU-%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%8A%80%E6%9C%AF"><span class="toc-number">1.5.</span> <span class="toc-text">五、存储器与 CPU 的连接技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E6%80%BB%E7%BA%BF%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%88%86%E7%B1%BB"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1 总线的作用与分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%AD%98%E5%82%A8%E5%99%A8%E5%AE%B9%E9%87%8F%E6%89%A9%E5%B1%95"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2 存储器容量扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1-%E4%BD%8D%E6%89%A9%E5%B1%95"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">5.2.1 位扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2-%E5%AD%97%E6%89%A9%E5%B1%95"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">5.2.2 字扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-3-%E5%AD%97%E4%BD%8D%E5%90%8C%E6%97%B6%E6%89%A9%E5%B1%95"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">5.2.3 字位同时扩展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87%E7%9A%84%E7%89%87%E9%80%89%E6%8E%A7%E5%88%B6"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.3 存储芯片的片选控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-%E7%BA%BF%E9%80%89%E6%B3%95"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">5.3.1 线选法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2-%E8%AF%91%E7%A0%81%E6%B3%95"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">5.3.2 译码法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF"><span class="toc-number">1.6.</span> <span class="toc-text">六、存储器的校验技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E7%BC%96%E7%A0%81%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB%E4%B8%8E%E6%A3%80%E9%94%99%E7%BA%A0%E9%94%99%E8%83%BD%E5%8A%9B"><span class="toc-number">1.6.1.</span> <span class="toc-text">6.1 编码的最小距离与检错纠错能力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E7%A0%81"><span class="toc-number">1.6.2.</span> <span class="toc-text">6.2 奇偶校验码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1-%E5%A5%87%E6%A0%A1%E9%AA%8C"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">6.2.1 奇校验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2-%E5%81%B6%E6%A0%A1%E9%AA%8C"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">6.2.2 偶校验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-3-%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">6.2.3 局限性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E6%B1%89%E6%98%8E%E7%A0%81"><span class="toc-number">1.6.3.</span> <span class="toc-text">6.3 汉明码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-1-%E6%B1%89%E6%98%8E%E7%A0%81%E7%9A%84%E6%A0%A1%E9%AA%8C%E4%BD%8D%E6%95%B0%E9%87%8F%E4%B8%8E%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">6.3.1 汉明码的校验位数量与位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-2-%E6%B1%89%E6%98%8E%E7%A0%81%E7%9A%84%E6%A0%A1%E9%AA%8C%E4%BD%8D%E5%8F%96%E5%80%BC%E8%AE%A1%E7%AE%97"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">6.3.2 汉明码的校验位取值计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-3-%E6%B1%89%E6%98%8E%E7%A0%81%E9%85%8D%E7%BD%AE%E5%AE%9E%E4%BE%8B%EF%BC%88%E5%81%B6%E6%A0%A1%E9%AA%8C%EF%BC%89"><span class="toc-number">1.6.3.3.</span> <span class="toc-text">6.3.3 汉明码配置实例（偶校验）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-4-%E6%B1%89%E6%98%8E%E7%A0%81%E7%9A%84%E7%BA%A0%E9%94%99%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.3.4.</span> <span class="toc-text">6.3.4 汉明码的纠错过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-5-%E6%B1%89%E6%98%8E%E7%A0%81%E7%BA%A0%E9%94%99%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.6.3.5.</span> <span class="toc-text">6.3.5 汉明码纠错实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C%E7%A0%81%EF%BC%88CRC%EF%BC%89"><span class="toc-number">1.6.4.</span> <span class="toc-text">6.4 循环冗余校验码（CRC）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-1-CRC-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">6.4.1 CRC 的基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-2-CRC-%E6%A3%80%E9%94%99%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">6.4.2 CRC 检错过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-3-CRC-%E5%AE%9E%E4%BE%8B%EF%BC%88%E4%BB%A5-CRC-3-%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">1.6.4.3.</span> <span class="toc-text">6.4.3 CRC 实例（以 CRC-3 为例）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%8F%90%E9%AB%98%E8%AE%BF%E5%AD%98%E9%80%9F%E5%BA%A6%E7%9A%84%E6%8E%AA%E6%96%BD"><span class="toc-number">1.7.</span> <span class="toc-text">七、提高访存速度的措施</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E9%87%87%E7%94%A8%E9%AB%98%E9%80%9F%E5%AD%98%E5%82%A8%E5%99%A8%E4%BB%B6"><span class="toc-number">1.7.1.</span> <span class="toc-text">7.1 采用高速存储器件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-1-%E9%AB%98%E9%80%9F-SRAM-%E8%8A%AF%E7%89%87"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">7.1.1 高速 SRAM 芯片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-2-%E5%A2%9E%E5%BC%BA%E5%9E%8B-DRAM-%E8%8A%AF%E7%89%87"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">7.1.2 增强型 DRAM 芯片</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E5%BC%95%E5%85%A5-Cache-%E4%B8%BB%E5%AD%98%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.2.</span> <span class="toc-text">7.2 引入 Cache - 主存层次结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-1-%E7%A8%8B%E5%BA%8F%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86%EF%BC%88Cache-%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%EF%BC%89"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">7.2.1 程序局部性原理（Cache 设计的理论基础）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-2-Cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">7.2.2 Cache 的基本结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-3-%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E6%96%B9%E5%BC%8F%EF%BC%88Cache-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%EF%BC%89"><span class="toc-number">1.7.2.3.</span> <span class="toc-text">7.2.3 地址映射方式（Cache 核心技术）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-3-1-%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84"><span class="toc-number">1.7.2.3.1.</span> <span class="toc-text">7.2.3.1 直接映射</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-3-2-%E5%85%A8%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84"><span class="toc-number">1.7.2.4.</span> <span class="toc-text">7.2.3.2 全相联映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-3-3-%E7%BB%84%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84%EF%BC%88%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%A8%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84%E7%9A%84%E6%8A%98%E4%B8%AD%EF%BC%89"><span class="toc-number">1.7.2.5.</span> <span class="toc-text">7.2.3.3 组相联映射（直接映射与全相联映射的折中）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-4-Cache-%E7%9A%84%E5%86%99%E7%AD%96%E7%95%A5%EF%BC%88%E8%A7%A3%E5%86%B3-Cache-%E4%B8%8E%E4%B8%BB%E5%AD%98%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%89"><span class="toc-number">1.7.2.6.</span> <span class="toc-text">7.2.4 Cache 的写策略（解决 Cache 与主存数据一致性）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-4-1-%E5%86%99%E7%9B%B4%E8%BE%BE%EF%BC%88Write-Through%EF%BC%89"><span class="toc-number">1.7.2.6.1.</span> <span class="toc-text">7.2.4.1 写直达（Write-Through）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-4-2-%E5%86%99%E5%9B%9E%EF%BC%88Write-Back%EF%BC%89"><span class="toc-number">1.7.2.6.2.</span> <span class="toc-text">7.2.4.2 写回（Write-Back）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E8%B0%83%E6%95%B4%E4%B8%BB%E5%AD%98%E7%BB%93%E6%9E%84%EF%BC%88%E5%A4%9A%E4%BD%93%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%8D%95%E4%BD%93%E5%A4%9A%E5%AD%97%EF%BC%89"><span class="toc-number">1.7.3.</span> <span class="toc-text">7.3 调整主存结构（多体并行与单体多字）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-1-%E5%8D%95%E4%BD%93%E5%A4%9A%E5%AD%97%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">7.3.1 单体多字系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-2-%E5%A4%9A%E4%BD%93%E5%B9%B6%E8%A1%8C%E7%B3%BB%E7%BB%9F%EF%BC%88%E6%A0%B8%E5%BF%83%E6%96%B9%E6%A1%88%EF%BC%89"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">7.3.2 多体并行系统（核心方案）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-3-2-1-%E9%AB%98%E4%BD%8D%E4%BA%A4%E5%8F%89%E7%BC%96%E5%9D%80%EF%BC%88%E9%A1%BA%E5%BA%8F%E7%BC%96%E5%9D%80%EF%BC%89"><span class="toc-number">1.7.3.2.1.</span> <span class="toc-text">7.3.2.1 高位交叉编址（顺序编址）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-3-2-2-%E4%BD%8E%E4%BD%8D%E4%BA%A4%E5%8F%89%E7%BC%96%E5%9D%80%EF%BC%88%E4%BA%A4%E5%8F%89%E7%BC%96%E5%9D%80%EF%BC%8C%E6%A0%B8%E5%BF%83%E4%BC%98%E5%8C%96%EF%BC%89"><span class="toc-number">1.7.3.2.2.</span> <span class="toc-text">7.3.2.2 低位交叉编址（交叉编址，核心优化）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E9%87%87%E7%94%A8%E9%AB%98%E6%80%A7%E8%83%BD%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87%EF%BC%88DRAM-%E6%8A%80%E6%9C%AF%E6%BC%94%E8%BF%9B%EF%BC%89"><span class="toc-number">1.7.4.</span> <span class="toc-text">7.4 采用高性能存储芯片（DRAM 技术演进）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-1-SDRAM%EF%BC%88%E5%90%8C%E6%AD%A5-DRAM%EF%BC%89"><span class="toc-number">1.7.4.1.</span> <span class="toc-text">7.4.1 SDRAM（同步 DRAM）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-2-DDR-SDRAM%EF%BC%88%E5%8F%8C%E5%80%8D%E6%95%B0%E6%8D%AE%E7%8E%87%E5%90%8C%E6%AD%A5-DRAM%EF%BC%89"><span class="toc-number">1.7.4.2.</span> <span class="toc-text">7.4.2 DDR SDRAM（双倍数据率同步 DRAM）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-3-RDRAM%EF%BC%88Rambus-DRAM%EF%BC%89"><span class="toc-number">1.7.4.3.</span> <span class="toc-text">7.4.3 RDRAM（Rambus DRAM）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-4-%E5%B8%A6-Cache-%E7%9A%84-DRAM%EF%BC%88CDRAM%EF%BC%89"><span class="toc-number">1.7.4.4.</span> <span class="toc-text">7.4.4 带 Cache 的 DRAM（CDRAM）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E4%B8%8E%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B"><span class="toc-number">1.8.</span> <span class="toc-text">八、存储系统的性能评估与优化案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E6%8C%87%E6%A0%87"><span class="toc-number">1.8.1.</span> <span class="toc-text">8.1 存储系统性能评估指标</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-1-Cache-%E5%91%BD%E4%B8%AD%E7%8E%87%EF%BC%88H%EF%BC%89"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">8.1.1 Cache 命中率（H）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-2-%E5%B9%B3%E5%9D%87%E5%AD%98%E5%8F%96%E6%97%B6%E9%97%B4%EF%BC%88Tavg%EF%BC%89"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">8.1.2 平均存取时间（Tavg）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-3-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B8%A6%E5%AE%BD%EF%BC%88B%EF%BC%89"><span class="toc-number">1.8.1.3.</span> <span class="toc-text">8.1.3 存储器带宽（B）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%EF%BC%88%E4%BB%A5-PC-%E4%B8%BB%E6%9C%BA%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">1.8.2.</span> <span class="toc-text">8.2 存储系统优化案例（以 PC 主机为例）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-%E6%B6%88%E8%B4%B9%E7%BA%A7-PC-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%EF%BC%88%E5%85%BC%E9%A1%BE%E6%88%90%E6%9C%AC%E4%B8%8E%E6%80%A7%E8%83%BD%EF%BC%89"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">8.2.1 消费级 PC 存储系统优化（兼顾成本与性能）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-2-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%EF%BC%88%E4%BE%A7%E9%87%8D%E9%AB%98%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%8F%AF%E9%9D%A0%E6%80%A7%EF%BC%89"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">8.2.2 服务器存储系统优化（侧重高带宽与可靠性）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E8%B6%8B%E5%8A%BF"><span class="toc-number">1.9.</span> <span class="toc-text">九、存储系统的发展趋势</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E9%9D%9E%E6%98%93%E5%A4%B1%E6%80%A7%E5%AD%98%E5%82%A8%E5%99%A8%EF%BC%88NVM%EF%BC%89%E7%9A%84%E6%99%AE%E5%8F%8A%E4%B8%8E%E6%9E%B6%E6%9E%84%E9%9D%A9%E6%96%B0"><span class="toc-number">1.9.1.</span> <span class="toc-text">9.1 非易失性存储器（NVM）的普及与架构革新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-3D-%E5%A0%86%E5%8F%A0%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E8%A7%84%E6%A8%A1%E5%8C%96%E5%BA%94%E7%94%A8"><span class="toc-number">1.9.2.</span> <span class="toc-text">9.2 3D 堆叠存储技术的规模化应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E5%AD%98%E5%82%A8%E7%BA%A7%E5%86%85%E5%AD%98%EF%BC%88SCM%EF%BC%89%E7%9A%84%E4%BA%A7%E4%B8%9A%E5%8C%96%E8%90%BD%E5%9C%B0"><span class="toc-number">1.9.3.</span> <span class="toc-text">9.3 存储级内存（SCM）的产业化落地</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-%E5%AD%98%E5%82%A8-%E8%AE%A1%E7%AE%97%E4%B8%80%E4%BD%93%E5%8C%96%EF%BC%88In-Memory-Computing-Storage-Class-Computing%EF%BC%89"><span class="toc-number">1.9.4.</span> <span class="toc-text">9.4 存储 - 计算一体化（In-Memory Computing&#x2F;Storage-Class Computing）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%99%BA%E8%83%BD%E5%8C%96%E4%B8%8E%E8%87%AA%E4%BC%98%E5%8C%96"><span class="toc-number">1.9.5.</span> <span class="toc-text">9.5 存储系统的智能化与自优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E6%80%BB%E7%BB%93%E4%B8%8E%E5%B1%95%E6%9C%9B"><span class="toc-number">1.10.</span> <span class="toc-text">十、总结与展望</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93"><span class="toc-number">1.10.1.</span> <span class="toc-text">10.1 核心知识总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E6%9C%AA%E6%9D%A5%E5%B1%95%E6%9C%9B"><span class="toc-number">1.10.2.</span> <span class="toc-text">10.2 未来展望</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/8-ji-suan-ji-zu-cheng-yuan-li-fu-zhu-cun-chu-qi-shen-du-jie-xi/" title="8、计算机组成原理: 辅助存储器深度解析">8、计算机组成原理: 辅助存储器深度解析</a><time datetime="2025-09-24T13:23:41.000Z" title="发表于 2025-09-24 21:23:41">2025-09-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/7-ji-suan-ji-zu-cheng-yuan-li-shen-ru-li-jie-gao-su-huan-chong-cun-chu-qi-cache/" title="7、计算机组成原理: 深入理解高速缓冲存储器（Cache)">7、计算机组成原理: 深入理解高速缓冲存储器（Cache)</a><time datetime="2025-09-21T13:56:21.000Z" title="发表于 2025-09-21 21:56:21">2025-09-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/6-ji-suan-ji-zu-cheng-yuan-li-shen-ru-xue-xi-cun-chu-xi-tong/" title="6、计算机组成原理: 深入学习存储系统">6、计算机组成原理: 深入学习存储系统</a><time datetime="2025-09-04T13:40:00.000Z" title="发表于 2025-09-04 21:40:00">2025-09-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/5-ji-suan-ji-zu-cheng-yuan-li-cun-chu-qi-yuan-li-fen-xi/" title="5、计算机组成原理: 存储器原理分析">5、计算机组成原理: 存储器原理分析</a><time datetime="2025-09-04T13:34:06.000Z" title="发表于 2025-09-04 21:34:06">2025-09-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/4-ji-suan-ji-zu-cheng-yuan-li-tan-suo-zong-xian-yan-jin-guo-cheng/" title="4、计算机组成原理: 探索总线演进过程">4、计算机组成原理: 探索总线演进过程</a><time datetime="2025-09-02T23:37:21.000Z" title="发表于 2025-09-03 07:37:21">2025-09-03</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By lvting.chi</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>