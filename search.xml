<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>1、计算机组成原理初窥: 底层逻辑</title>
      <link href="/2025/08/27/ji-suan-ji-zu-cheng-yuan-li-chu-kui-1-liao-jie-di-ceng-luo-ji/"/>
      <url>/2025/08/27/ji-suan-ji-zu-cheng-yuan-li-chu-kui-1-liao-jie-di-ceng-luo-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="1、计算机组成原理初窥-底层逻辑"><a href="#1、计算机组成原理初窥-底层逻辑" class="headerlink" title="1、计算机组成原理初窥: 底层逻辑"></a>1、计算机组成原理初窥: 底层逻辑</h1><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>计算机组成原理，作为计算机专业基石课程，搭建起从硬件电路到软件运行的理解桥梁。初次接触其知识体系，恰似打开神秘黑箱，看清内部精密协作的齿轮，知晓程序如何在硬件舞台上 “翩翩起舞”，理解计算机系统如何高效运转。本文从程序执行流程、计算机硬件结构、指令系统、体系结构设计等维度，深入探寻计算机组成原理的奥秘，为后续深入学习筑牢根基。</p><h2 id="二、程序执行：指令的-“生命旅程”"><a href="#二、程序执行：指令的-“生命旅程”" class="headerlink" title="二、程序执行：指令的 “生命旅程”"></a>二、程序执行：指令的 “生命旅程”</h2><h3 id="（一）从高级语言到机器指令"><a href="#（一）从高级语言到机器指令" class="headerlink" title="（一）从高级语言到机器指令"></a>（一）从高级语言到机器指令</h3><p>当我们在编程时写下<code>z = x + y</code>这样简洁的高级语言表达式，计算机无法直接理解。高级语言需经过编译或解释过程，转化为机器指令序列，这是计算机能识别并执行的 “母语”。机器指令由 0 和 1 组成的二进制代码构成，对应着计算机硬件可直接操作的基本动作。</p><h3 id="（二）指令执行的-“三步走”"><a href="#（二）指令执行的-“三步走”" class="headerlink" title="（二）指令执行的 “三步走”"></a>（二）指令执行的 “三步走”</h3><p>程序执行核心流程可概括为取指令、分析指令（解码）、执行指令，循环往复直至程序结束，时钟信号如同精准的 “节拍器”，驱动每一步有序推进。</p><ol><li><strong>取指令</strong>：CPU 从存储器中指定位置（由程序计数器 PC 指向）读取指令。比如执行<code>z = x + y</code>，首先要获取<code>LOAD X</code>指令，此时存储器需准确将该指令数据传输到 CPU 指令寄存器。程序计数器随后自动递增，指向下一条待执行指令地址，为后续取指令做准备。</li><li><strong>分析指令（解码）</strong>：指令寄存器中的指令进入指令译码器，译码器解析指令操作码与操作数。对于<code>LOAD X</code>，操作码表明是 “加载” 操作，操作数指明是存储单元中的<code>X</code>数据。译码器依据解析结果，生成控制信号，告知计算机各部件如何协作完成该指令。</li><li><strong>执行指令</strong>：控制信号驱动硬件执行具体操作。<code>LOAD X</code>执行时，CPU 通过总线等通路，从存储器对应地址取出<code>X</code>的值，存入内部寄存器。接着依次执行<code>LOAD Y</code>（将<code>Y</code>值载入另一寄存器 ）、<code>ADD</code>（两寄存器值相加，结果存入新寄存器 ）、<code>STORE Z</code>（将相加结果写回存储器<code>Z</code>对应地址 ）等指令，完成<code>z = x + y</code>的计算。</li></ol><h3 id="（三）时钟信号的关键作用"><a href="#（三）时钟信号的关键作用" class="headerlink" title="（三）时钟信号的关键作用"></a>（三）时钟信号的关键作用</h3><p>时钟提供连续脉冲流，所有内部操作在时钟脉冲触发下同步进行。时钟频率（单位时间内脉冲数）影响计算机速度，频率越高，理论上单位时间能执行指令数越多。但过高频率会带来功耗、散热等问题，需在性能与稳定性间平衡，如手机 CPU 会根据负载动态调整时钟频率，兼顾性能与续航。</p><h2 id="三、通用计算机结构：硬件的-“协作网络”"><a href="#三、通用计算机结构：硬件的-“协作网络”" class="headerlink" title="三、通用计算机结构：硬件的 “协作网络”"></a>三、通用计算机结构：硬件的 “协作网络”</h2><h3 id="（一）核心组成：CPU-与存储器系统"><a href="#（一）核心组成：CPU-与存储器系统" class="headerlink" title="（一）核心组成：CPU 与存储器系统"></a>（一）核心组成：CPU 与存储器系统</h3><ol><li><p><strong>CPU：计算机的 “大脑”</strong><br>CPU 是程序执行核心，内部集成运算器（如算术逻辑单元 ALU，负责<code>x + y</code>等运算 ）、控制器（生成控制信号，协调计算机各部件 ）、寄存器（临时存储数据与指令，像执行<code>z = x + y</code>时，寄存器暂存<code>x</code>、<code>y</code>、<code>z</code>值，加快数据访问 ）。寄存器数量有限但速度极快，靠近运算器与控制器，减少数据传输延迟，提升处理效率。</p></li><li><p>存储器系统：数据的 “仓库”</p><p>存储器系统承担存储程序和数据的任务，为平衡速度、容量、成本，采用分层架构：</p><ul><li><strong>高速缓存（Cache）</strong>：是 CPU 与主存间的高速、小容量存储器，存放 CPU 近期常用数据和指令。因 CPU 访问 Cache 速度远快于主存，可大幅减少 CPU 等待数据时间。现代 CPU 常集成多级 Cache，如 L1 Cache 速度最快、容量最小，L2、L3 Cache 容量渐大、速度稍慢，构建 “高速 - 容量” 平衡的存储层次。</li><li><strong>主存（DRAM）</strong>：即我们常说的内存，存储计算机运行时的大量工作数据和程序。它速度快于辅存，可直接与 CPU 交互，但断电后数据丢失，容量也受成本等限制，一般几十 GB 到上百 GB。</li><li><strong>辅存（如硬盘、SSD、CD - ROM ）</strong>：用于长期、海量数据存储，像计算机操作系统、大型软件、用户文件等存于此处。硬盘通过磁介质存储，SSD 基于闪存，CD - ROM 是光盘存储。辅存容量大（从几百 GB 到几 TB 甚至 PB 级 ），但访问速度慢于主存，需借助 I/O 操作与主存交换数据。</li></ul></li></ol><h3 id="（二）连接纽带：总线"><a href="#（二）连接纽带：总线" class="headerlink" title="（二）连接纽带：总线"></a>（二）连接纽带：总线</h3><p>总线是计算机各部件间传输数据、地址、控制信号的公共通道，如同城市交通网络，保障各硬件 “通信” 顺畅。</p><ol><li><strong>数据总线</strong>：传输指令、数据，宽度（一次传输二进制位数）影响数据传输速率，如 64 位数据总线一次可传 64 位数据，提升 CPU 与存储器、I/O 设备间数据交换效率。</li><li><strong>地址总线</strong>：传输内存单元或 I/O 设备的地址信息，其宽度决定计算机可寻址空间大小。比如 32 位地址总线，可寻址空间为 2³² 字节（约 4GB ），64 位地址总线则能支持更大内存寻址。</li><li><strong>控制总线</strong>：传递控制信号与时序信号，协调各部件操作，如 CPU 通过控制总线向存储器发送 “读”“写” 命令，存储器回传 “忙”“就绪” 等状态信号。</li></ol><h3 id="（三）输入输出子系统"><a href="#（三）输入输出子系统" class="headerlink" title="（三）输入输出子系统"></a>（三）输入输出子系统</h3><p>输入输出（I/O）子系统实现计算机与外部设备（如键盘、鼠标、显示器、打印机等 ）的数据交互。I/O 控制器是关键部件，它像 “翻译官”，一边通过系统总线与 CPU、主存通信，另一边连接具体外设，适配不同外设的通信协议与数据格式。比如键盘按下一个键，键盘控制器将按键信号转换为计算机能识别的数据，通过总线传输到主存或 CPU 处理；显示器则接收计算机传来的图像数据，经显示控制器处理后显示画面。</p><h2 id="四、计算机指令"><a href="#四、计算机指令" class="headerlink" title="四、计算机指令"></a>四、计算机指令</h2><h3 id="（一）指令的分类与功能"><a href="#（一）指令的分类与功能" class="headerlink" title="（一）指令的分类与功能"></a>（一）指令的分类与功能</h3><p>计算机指令虽多样，但可归纳为几类基本指令，构建起程序执行的 “原子操作”：</p><ol><li>数据传输类<ul><li><code>MOV A, B</code>：实现数据复制，将<code>B</code>的值拷贝到<code>A</code>，可用于寄存器间、寄存器与存储单元间等数据转移，是数据在计算机内流动的基础指令。</li><li><code>LOAD A, B</code>：专门将存储单元<code>B</code>的值加载到寄存器<code>A</code>，为运算准备数据，如执行<code>z = x + y</code>时，<code>LOAD X</code>、<code>LOAD Y</code>就是此类指令，把内存中<code>x</code>、<code>y</code>值移入寄存器。</li><li><code>STORE A, B</code>：与<code>LOAD</code>相反，将寄存器<code>B</code>的值写入存储单元<code>A</code>，像计算完<code>z</code>后，<code>STORE Z</code>把寄存器中结果存回内存。</li></ul></li><li><strong>运算类</strong>：<code>ADD A, B</code> 让寄存器<code>A</code>与<code>B</code>中的值相加，结果存入<code>A</code>，是算术运算核心指令，除加法，还有减法（<code>SUB</code>）、乘法（<code>MUL</code>）、除法（<code>DIV</code>）等运算指令，满足不同计算需求。</li><li>控制转移类<ul><li><code>TEST A</code>：检测寄存器<code>A</code>的值是否为 0，设置相应标志位，为条件判断做准备。</li><li><code>BEQ Z</code>：若<code>TEST</code>等指令设置的标志位满足条件（如结果为真 ），则跳转到地址<code>Z</code>处执行代码，实现程序分支、循环等逻辑，让程序具备 “智能判断” 能力。</li></ul></li></ol><h3 id="（二）指令与硬件的关联"><a href="#（二）指令与硬件的关联" class="headerlink" title="（二）指令与硬件的关联"></a>（二）指令与硬件的关联</h3><p>每条指令执行都依赖硬件协作。以<code>ADD A, B</code>为例，指令译码后，控制器生成控制信号，指挥运算器从寄存器<code>A</code>、<code>B</code>取数，在 ALU 中完成加法，再把结果送回寄存器<code>A</code>，过程中涉及寄存器读写、ALU 运算、控制信号传递等硬件操作，体现指令与硬件紧密的映射关系。</p><h2 id="五、计算机体系结构设计：多维平衡"><a href="#五、计算机体系结构设计：多维平衡" class="headerlink" title="五、计算机体系结构设计：多维平衡"></a>五、计算机体系结构设计：多维平衡</h2><h3 id="（一）硬件物理组织：层次与协同"><a href="#（一）硬件物理组织：层次与协同" class="headerlink" title="（一）硬件物理组织：层次与协同"></a>（一）硬件物理组织：层次与协同</h3><p>计算机系统体系结构需考量硬件物理组织，合理布局 CPU、Cache、主存、I/O 设备等。如将 Cache 置于 CPU 附近，缩短数据传输路径；通过系统总线、扩展总线等分层总线架构，连接不同速度设备，让高速设备（如 CPU、主存 ）和低速设备（如打印机 ）都能高效工作，避免相互 “拖后腿”。</p><h3 id="（二）设计因素的交织影响"><a href="#（二）设计因素的交织影响" class="headerlink" title="（二）设计因素的交织影响"></a>（二）设计因素的交织影响</h3><ol><li><strong>技术演进</strong>：半导体技术进步推动硬件性能提升，如芯片制程从微米级迈向纳米级，让 CPU 集成更多晶体管，实现更复杂指令集与更高时钟频率。新存储技术（如 3D NAND ）提升辅存容量与速度，影响存储器体系结构设计。</li><li><strong>异常处理</strong>：计算机运行中会遇到中断（如外设请求、程序错误 ）、故障（如硬件损坏 ）等异常，需设计完善异常处理机制。CPU 设置中断向量表，记录不同异常处理程序地址，异常发生时快速跳转处理，保障系统稳定，像程序除零错误会触发中断，转入错误处理流程。</li><li><strong>性能优化</strong>：追求高性能是体系结构设计重要目标，但需平衡 CPU、存储、I/O 子系统性能。若 CPU 运算速度极快，而主存数据供应不足（即 “存储墙” 问题 ），CPU 会频繁等待数据，整体性能无法发挥。所以要通过 Cache 优化、内存带宽提升、I/O 接口升级（如 USB 3.0/4.0、PCIe ）等，让各子系统协同高效。</li><li><strong>应用需求导向</strong>：不同应用场景对计算机体系结构要求不同。服务器需高吞吐量、多任务处理能力，采用多核 CPU、大内存、高速网络接口；嵌入式系统注重低功耗、小体积，如智能手表 CPU 简化设计，平衡性能与功耗，适配便携场景。</li><li><strong>操作系统与编译器适配</strong>：操作系统负责资源管理与调度，体系结构需提供硬件支持，如 CPU 特权级设计，保障操作系统内核安全。编译器将高级语言编译为机器指令，需考虑硬件指令集特性，合理生成指令序列，发挥硬件性能，如利用 CPU 流水线、向量化指令优化代码。</li><li><strong>功耗控制</strong>：移动设备对功耗敏感，体系结构设计需引入功耗管理技术，如 CPU 动态降频（负载低时降低时钟频率 ）、关断闲置部件电源，在满足性能需求同时，延长设备续航。</li></ol><h2 id="六、总结与展望"><a href="#六、总结与展望" class="headerlink" title="六、总结与展望"></a>六、总结与展望</h2><p>本文从程序执行的微观指令流程，到计算机硬件的宏观架构协作，再到指令系统的基础逻辑、体系结构的多因素平衡，层层深入，展现计算机系统 “精密协作、高效运转” 的底层逻辑。</p><p>后续学习中，我们将深入钻研 CPU 内部微架构（如流水线、超标量、乱序执行 ）、存储器详细工作原理（如 DRAM 刷新机制、Cache 映射策略 ）、I/O 系统深入知识（如 DMA 直接内存访问 ）等内容，不断解锁计算机组成原理的更深奥秘，为理解计算机前沿技术（如量子计算、异构计算 ）奠定基础，真正成为能看透计算机 “本质” 的技术开发者与探索者，在计算机技术浪潮中把握发展脉络，创造新的可能。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C 语言位操作</title>
      <link href="/2025/08/25/c-yu-yan-yi-wei-cao-zuo/"/>
      <url>/2025/08/25/c-yu-yan-yi-wei-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h1 id="C-语言位操作"><a href="#C-语言位操作" class="headerlink" title="C 语言位操作"></a>C 语言位操作</h1><p>在 C 语言编程中，位操作是一项基础而强大的技术。它允许我们直接与数据的二进制表示进行交互，实现高效的内存利用和精确的硬件控制。本文将深入探讨位操作的核心应用 —— 如何精准地将某个二进制位置为 1 或清为 0，以及这些操作背后的原理和实践技巧。</p><h2 id="一、二进制位的基础知识"><a href="#一、二进制位的基础知识" class="headerlink" title="一、二进制位的基础知识"></a>一、二进制位的基础知识</h2><p>在计算机系统中，所有数据都以二进制形式存储。无论是整数、字符还是浮点数，最终都会被转换为一系列的 0 和 1（位）。对于一个典型的 32 位整数，它由 32 个二进制位组成，每个位的位置从右向左（从低到高）编号为 0 到 31。</p><p>例如，十进制数 13 的二进制表示为<code>00000000 00000000 00000000 00001101</code>，其中第 0 位、第 2 位和第 3 位是 1，其余位是 0。</p><p>位操作的核心优势在于：它可以单独修改一个或多个特定的位，而不影响其他位的状态。这在嵌入式系统、驱动程序开发、数据压缩等领域尤为重要。</p><h2 id="二、位运算的基本工具"><a href="#二、位运算的基本工具" class="headerlink" title="二、位运算的基本工具"></a>二、位运算的基本工具</h2><p>C 语言提供了几种基本的位运算符，它们是实现位操作的基础：</p><ul><li><strong>按位与（&amp;）</strong>：两个位都为 1 时，结果为 1，否则为 0</li><li><strong>按位或（|）</strong>：两个位中至少有一个为 1 时，结果为 1，否则为 0</li><li><strong>按位异或（^）</strong>：两个位不同时结果为 1，相同时结果为 0</li><li><strong>按位非（~）</strong>：将位取反，1 变为 0，0 变为 1</li><li><strong>左移（&lt;&lt;）</strong>：将所有位向左移动指定的位数</li><li><strong>右移（&gt;&gt;）</strong>：将所有位向右移动指定的位数</li></ul><p>这些运算符将帮助我们实现对位的精确控制，尤其是结合移位操作生成特定的 “掩码”（mask）时，能发挥强大的作用。</p><h2 id="三、将某一位置为-1-的原理与实现"><a href="#三、将某一位置为-1-的原理与实现" class="headerlink" title="三、将某一位置为 1 的原理与实现"></a>三、将某一位置为 1 的原理与实现</h2><p>将一个数的第 n 位置为 1（而不影响其他位）是最常用的位操作之一。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>实现这一操作的核心是使用<strong>按位或（|）</strong> 运算符。按位或的特性是：任何位与 1 进行或运算结果都是 1，与 0 进行或运算则保持原值不变。</p><p>因此，我们需要构造一个 “掩码”—— 一个只有第 n 位为 1，其余位都为 0 的数。然后将原始数据与这个掩码进行按位或运算，即可将第 n 位置为 1，同时保持其他位不变。</p><h3 id="掩码的构造"><a href="#掩码的构造" class="headerlink" title="掩码的构造"></a>掩码的构造</h3><p>要生成第 n 位为 1 的掩码，我们可以利用左移操作：<code>1 &lt;&lt; n</code>。</p><ul><li>初始值 1 的二进制表示是<code>000...0001</code>（只有第 0 位为 1）</li><li>将其左移 n 位后，1 就移动到了第 n 位，形成<code>000...1...000</code>的形式</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 将num的第n位置为1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">set_bit</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="keyword">return</span> num | (<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="示例解析"><a href="#示例解析" class="headerlink" title="示例解析"></a>示例解析</h3><p>假设我们有一个数<code>a = 5</code>（二进制<code>00000101</code>），想将其第 1 位置为 1：</p><ol><li>计算掩码：<code>1 &lt;&lt; 1 = 2</code>（二进制<code>00000010</code>）</li><li>执行按位或运算：<code>5 | 2 = 7</code>（二进制<code>00000111</code>）</li></ol><p>结果是第 1 位被成功置为 1，其他位保持不变。</p><h2 id="四、将某一位清为-0-的原理与实现"><a href="#四、将某一位清为-0-的原理与实现" class="headerlink" title="四、将某一位清为 0 的原理与实现"></a>四、将某一位清为 0 的原理与实现</h2><p>与置位操作相对应，我们经常需要将某个特定位清为 0，同时保持其他位不变。</p><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><p>这一操作的核心是使用<strong>按位与（&amp;）</strong> 运算符。按位与的特性是：任何位与 0 进行与运算结果都是 0，与 1 进行与运算则保持原值不变。</p><p>因此，我们需要构造一个掩码 —— 只有第 n 位为 0，其余位都为 1 的数。然后将原始数据与这个掩码进行按位与运算，即可将第 n 位清为 0，同时保持其他位不变。</p><h3 id="掩码的构造-1"><a href="#掩码的构造-1" class="headerlink" title="掩码的构造"></a>掩码的构造</h3><p>要生成第 n 位为 0 的掩码，我们可以先通过<code>1 &lt;&lt; n</code>得到第 n 位为 1 的掩码，再对其进行按位非（<del>）操作：`</del>(1 &lt;&lt; n)`。</p><ul><li><code>1 &lt;&lt; n</code>生成第 n 位为 1 的掩码</li><li>按位非操作将所有位取反，使第 n 位变为 0，其他位变为 1</li></ul><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 将num的第n位清为0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">clear_bit</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="keyword">return</span> num &amp; ~(<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="示例解析-1"><a href="#示例解析-1" class="headerlink" title="示例解析"></a>示例解析</h3><p>假设我们有一个数<code>a = 7</code>（二进制<code>00000111</code>），想将其第 1 位清为 0：</p><ol><li>计算掩码：<code>~(1 &lt;&lt; 1) = ~2 = ...11111101</code>（二进制）</li><li>执行按位与运算：<code>7 &amp; ~2 = 5</code>（二进制<code>00000101</code>）</li></ol><p>结果是第 1 位被成功清为 0，其他位保持不变。</p><h2 id="五、扩展应用：位操作的更多技巧"><a href="#五、扩展应用：位操作的更多技巧" class="headerlink" title="五、扩展应用：位操作的更多技巧"></a>五、扩展应用：位操作的更多技巧</h2><p>掌握了单个位的置 1 和清 0 操作后，我们可以扩展到更复杂的位操作。</p><h3 id="1-检查某一位是否为-1"><a href="#1-检查某一位是否为-1" class="headerlink" title="1. 检查某一位是否为 1"></a>1. 检查某一位是否为 1</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 检查num的第n位是否为1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_bit_set</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="keyword">return</span> (num &amp; (<span class="number">1</span> &lt;&lt; n)) != <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>原理：如果第 n 位为 1，则与掩码<code>1 &lt;&lt; n</code>进行与运算的结果非 0；否则结果为 0。</p><h3 id="2-翻转某一位的值"><a href="#2-翻转某一位的值" class="headerlink" title="2. 翻转某一位的值"></a>2. 翻转某一位的值</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 翻转num的第n位（0变1，1变0）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">toggle_bit</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="keyword">return</span> num ^ (<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>原理：使用异或（^）运算，与 1 异或会翻转位值，与 0 异或则保持不变。</p><h3 id="3-操作连续的多位"><a href="#3-操作连续的多位" class="headerlink" title="3. 操作连续的多位"></a>3. 操作连续的多位</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 将num的第n到m位置为1（n &lt;= m）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">set_bits_range</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> n, <span class="type">int</span> m)</span> {</span><br><span class="line">    <span class="type">int</span> mask = ((<span class="number">1</span> &lt;&lt; (m - n + <span class="number">1</span>)) - <span class="number">1</span>) &lt;&lt; n;</span><br><span class="line">    <span class="keyword">return</span> num | mask;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将num的第n到m位清为0（n &lt;= m）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">clear_bits_range</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> n, <span class="type">int</span> m)</span> {</span><br><span class="line">    <span class="type">int</span> mask = ~(((<span class="number">1</span> &lt;&lt; (m - n + <span class="number">1</span>)) - <span class="number">1</span>) &lt;&lt; n);</span><br><span class="line">    <span class="keyword">return</span> num &amp; mask;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="六、注意事项与最佳实践"><a href="#六、注意事项与最佳实践" class="headerlink" title="六、注意事项与最佳实践"></a>六、注意事项与最佳实践</h2><ol><li><strong>位的编号方式</strong>：通常我们从 0 开始编号，最右边的位是第 0 位。</li><li><strong>数据类型范围</strong>：对于 32 位整数，位的编号范围是 0-31；对于 64 位整数，则是 0-63。移位操作的位数不能超过这个范围，否则行为是未定义的。</li><li><strong>符号位问题</strong>：对于有符号整数，右移操作的行为可能因编译器而异（算术右移或逻辑右移）。进行位操作时，建议使用无符号类型（如<code>unsigned int</code>）以避免符号位带来的意外行为。</li><li><strong>可读性考虑</strong>：位操作虽然高效，但可能降低代码可读性。建议使用宏定义或函数封装常用的位操作，并添加清晰的注释。</li></ol><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 宏定义形式的位操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SET_BIT(num, n)  ((num) | (1 &lt;&lt; (n)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLEAR_BIT(num, n) ((num) &amp; ~(1 &lt;&lt; (n)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_BIT_SET(num, n) (((num) &amp; (1 &lt;&lt; (n))) != 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOGGLE_BIT(num, n) ((num) ^ (1 &lt;&lt; (n)))</span></span><br></pre></td></tr></tbody></table></figure><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>位操作是 C 语言中一项强大而精炼的技术，通过巧妙地使用按位运算符和移位操作，我们可以精确控制数据的每一个二进制位。将某一位置为 1 或清为 0 的操作，看似简单，却体现了位操作的核心思想：构造合适的掩码，利用位运算的特性实现精准控制。</p><p>这些技术在底层编程、嵌入式系统、驱动开发等领域有着广泛的应用。掌握位操作能帮助我们写出更高效的代码，还能加深我们对计算机系统底层工作原理的理解。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/08/23/hello-world/"/>
      <url>/2025/08/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
