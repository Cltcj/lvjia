<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>2、计算机组成原理：概述 | Lvjia</title><meta name="author" content="lvting.chi"><meta name="copyright" content="lvting.chi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="2、计算机组成原理：概述一、引言计算机组成原理是计算机科学与技术领域的核心课程，它搭建起了从硬件底层到软件应用的桥梁。对于初学者而言，这是打开计算机世界大门的钥匙，能让他们明白日常使用的软件是如何在硬件上运行的；对于有经验的开发者或工程师来说，深入理解计算机组成原理，有助于在系统优化、性能调优等方面获得突破，能从底层逻辑去思考和解决问题。接下来，我们将从计算机系统的整体认知开始，逐步深入到各个核心">
<meta property="og:type" content="article">
<meta property="og:title" content="2、计算机组成原理：概述">
<meta property="og:url" content="http://lvjia.netlify.app/2-ji-suan-ji-zu-cheng-yuan-li-gai-shu/index.html">
<meta property="og:site_name" content="Lvjia">
<meta property="og:description" content="2、计算机组成原理：概述一、引言计算机组成原理是计算机科学与技术领域的核心课程，它搭建起了从硬件底层到软件应用的桥梁。对于初学者而言，这是打开计算机世界大门的钥匙，能让他们明白日常使用的软件是如何在硬件上运行的；对于有经验的开发者或工程师来说，深入理解计算机组成原理，有助于在系统优化、性能调优等方面获得突破，能从底层逻辑去思考和解决问题。接下来，我们将从计算机系统的整体认知开始，逐步深入到各个核心">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://lvjia.netlify.app/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-08-30T14:29:24.000Z">
<meta property="article:modified_time" content="2025-08-31T14:17:13.629Z">
<meta property="article:author" content="lvting.chi">
<meta property="article:tag" content="基础知识">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://lvjia.netlify.app/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "2、计算机组成原理：概述",
  "url": "http://lvjia.netlify.app/2-ji-suan-ji-zu-cheng-yuan-li-gai-shu/",
  "image": "http://lvjia.netlify.app/img/butterfly-icon.png",
  "datePublished": "2025-08-30T14:29:24.000Z",
  "dateModified": "2025-08-31T14:17:13.629Z",
  "author": [
    {
      "@type": "Person",
      "name": "lvting.chi",
      "url": "http://lvjia.netlify.app"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://lvjia.netlify.app/2-ji-suan-ji-zu-cheng-yuan-li-gai-shu/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '2、计算机组成原理：概述',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Lvjia" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Lvjia</span></a><a class="nav-page-title" href="/"><span class="site-name">2、计算机组成原理：概述</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">2、计算机组成原理：概述</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-08-30T14:29:24.000Z" title="发表于 2025-08-30 22:29:24">2025-08-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-31T14:17:13.629Z" title="更新于 2025-08-31 22:17:13">2025-08-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="2、计算机组成原理：概述"><a href="#2、计算机组成原理：概述" class="headerlink" title="2、计算机组成原理：概述"></a>2、计算机组成原理：概述</h1><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>计算机组成原理是计算机科学与技术领域的核心课程，它搭建起了从硬件底层到软件应用的桥梁。对于初学者而言，这是打开计算机世界大门的钥匙，能让他们明白日常使用的软件是如何在硬件上运行的；对于有经验的开发者或工程师来说，深入理解计算机组成原理，有助于在系统优化、性能调优等方面获得突破，能从底层逻辑去思考和解决问题。接下来，我们将从计算机系统的整体认知开始，逐步深入到各个核心组件和技术原理，带领大家全面探索计算机组成的奥秘。</p>
<h2 id="二、计算机系统整体认识"><a href="#二、计算机系统整体认识" class="headerlink" title="二、计算机系统整体认识"></a>二、计算机系统整体认识</h2><h3 id="（一）层次结构"><a href="#（一）层次结构" class="headerlink" title="（一）层次结构"></a>（一）层次结构</h3><p>计算机系统是一个多层次的结构，从最底层的硬件到最上层的应用软件，每一层都构建在其下一层的基础之上，并且每一层都为上一层提供服务。我们可以将其大致分为以下几个层次（从下到上）：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">微程序机器 M₀ ────────────────────── 微指令系统</span><br><span class="line">实际机器 M₁ ──────────────────────── 机器语言</span><br><span class="line">虚拟机器 ────────────────────────── 操作系统</span><br><span class="line">虚拟机器 M₂ ──────────────────────── 汇编语言</span><br><span class="line">虚拟机器 M₃ ──────────────────────── 高级语言</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>微程序机器（M₀）</strong>：这是计算机系统的最底层，由微指令系统控制。微指令是计算机能够直接识别和执行的最基本命令，它直接作用于硬件的逻辑电路，控制着数据通路和各个部件的操作。例如，控制 ALU（算术逻辑单元）进行加法运算，控制寄存器之间的数据传输等。</li>
<li><strong>实际机器（M₁）</strong>：由机器语言驱动。机器语言是由二进制代码组成的指令集合，每一条机器指令对应着微程序机器中的一段微程序。程序员如果直接使用机器语言编程，需要记忆大量的二进制指令代码，这非常繁琐且容易出错，但机器语言是计算机硬件能够直接执行的唯一语言。</li>
<li><strong>虚拟机器（操作系统层）</strong>：操作系统在这里扮演着关键角色。它对实际机器（M₁）进行了抽象和扩展，为上层提供了更便捷的服务和接口。例如，操作系统负责管理计算机的硬件资源（如 CPU、内存、I/O 设备等），提供进程管理、内存管理、文件系统等功能，使得上层的程序不需要直接与复杂的硬件打交道。</li>
<li><strong>虚拟机器（M₂，汇编语言层）</strong>：汇编语言是一种符号化的机器语言，它使用助记符来代替二进制的机器指令。汇编语言程序需要通过汇编器转换为机器语言程序才能被计算机执行。相比于机器语言，汇编语言更易于人类阅读和编写，同时它又能直接操作硬件，在系统编程、嵌入式开发等场景中有着广泛的应用。</li>
<li><strong>虚拟机器（M₃，高级语言层）</strong>：高级语言（如 C、Java、Python 等）是为了更方便人类编程而设计的。它具有更接近自然语言的语法和更丰富的抽象层次，程序员可以使用高级语言快速构建复杂的应用程序。高级语言程序需要通过编译器或解释器转换为汇编语言或机器语言程序才能在计算机上运行。</li>
</ul>
<h3 id="（二）体系结构与组成"><a href="#（二）体系结构与组成" class="headerlink" title="（二）体系结构与组成"></a>（二）体系结构与组成</h3><h4 id="2-2-1-计算机体系结构"><a href="#2-2-1-计算机体系结构" class="headerlink" title="2.2.1 计算机体系结构"></a>2.2.1 计算机体系结构</h4><p>计算机体系结构是程序员所看到的计算机系统的属性，是一种概念性的结构与功能特性描述。它主要包括指令系统、数据类型、寻址技术、I/O 机理等方面。例如，指令系统决定了计算机能够执行哪些操作，不同的计算机体系结构（如 x86、ARM 等）有着不同的指令系统；寻址技术规定了如何在内存中寻找操作数的地址，像直接寻址、间接寻址、寄存器寻址等都是常见的寻址方式。简单来说，计算机体系结构回答了 “计算机应该具备什么样的功能” 的问题。</p>
<h4 id="2-2-2-计算机组成"><a href="#2-2-2-计算机组成" class="headerlink" title="2.2.2 计算机组成"></a>2.2.2 计算机组成</h4><p>计算机组成是实现计算机体系结构所体现的属性，主要关注具体指令的实现等细节。比如，对于一条加法指令，计算机组成需要考虑如何通过硬件电路（如 ALU、寄存器等）来实现两个数的相加操作；如何设计控制信号的时序，确保加法操作的各个步骤（如取数、运算、存结果）按正确的顺序执行。计算机组成解决的是 “如何实现这些功能” 的问题。</p>
<h2 id="三、硬件核心技术指标"><a href="#三、硬件核心技术指标" class="headerlink" title="三、硬件核心技术指标"></a>三、硬件核心技术指标</h2><h3 id="（一）机器字长"><a href="#（一）机器字长" class="headerlink" title="（一）机器字长"></a>（一）机器字长</h3><p>机器字长是指 CPU 一次能处理数据的位数，它与 CPU 中的寄存器位数密切相关。寄存器是 CPU 内部用于临时存放数据的高速存储单元，寄存器的位数决定了 CPU 一次能处理数据的最大宽度。例如，一个 32 位字长的 CPU，其通用寄存器通常是 32 位的，一次能处理 32 位的数据；而 64 位字长的 CPU，通用寄存器为 64 位，一次能处理 64 位的数据。机器字长会影响计算机的运算精度和处理能力，字长越长，计算机的运算精度通常越高，能处理的数据范围也越广。</p>
<h3 id="（二）运算速度"><a href="#（二）运算速度" class="headerlink" title="（二）运算速度"></a>（二）运算速度</h3><p>运算速度是衡量计算机性能的重要指标，它反映了计算机执行指令的快慢。以下是几种常见的衡量运算速度的方式：</p>
<ul>
<li><strong>主频</strong>：CPU 的时钟频率，单位是赫兹（Hz）。时钟频率越高，CPU 在单位时间内产生的时钟周期数越多，理论上执行指令的速度就越快。例如，一个主频为 3GHz 的 CPU，意味着它每秒能产生 30 亿个时钟周期。</li>
<li><strong>核数与线程数</strong>：现代 CPU 通常具有多个核心（核数），每个核心又可以支持多个线程（线程数）。多核心和多线程技术使得 CPU 能够同时执行多个任务，从而提高整体的运算速度。比如，一个 4 核 8 线程的 CPU，能够同时处理 8 个线程的任务。</li>
<li><strong>吉普森法</strong>：</li>
</ul>
<p>$$<br>T_M = \sum_{i = 1}^{n} f_i t_i<br>$$</p>
<ul>
<li>其中T<sub>M</sub>是机器的平均执行时间，f<sub>i</sub>是第<em>i</em>种指令在程序中出现的频率，t<sub>i</sub>是第<em>i</em>种指令的执行时间。这种方法通过考虑不同指令的执行时间和出现频率来计算程序的平均执行时间，从而衡量计算机的运算速度，能更准确地反映计算机在实际程序运行中的性能。</li>
<li><strong>CPI（Clock Cycles Per Instruction）</strong>：执行一条指令所需的时钟周期数。CPI 的值越小，说明执行一条指令所需的时间越短，计算机的运算速度就越快。例如，一条指令的 CPI 为 1，意味着在一个时钟周期内就能完成这条指令的执行。</li>
<li><strong>MIPS（Million Instructions Per Second）</strong>：每秒执行百万条指令。这是一个常用的衡量计算机整数运算速度的指标，MIPS 值越高，说明计算机执行整数指令的速度越快。</li>
<li><strong>FLOPS（Floating - Point Operations Per Second）</strong>：每秒浮点运算次数。主要用于衡量计算机的浮点运算能力，在科学计算、图形处理等需要大量浮点运算的领域，FLOPS 是一个关键的性能指标。</li>
</ul>
<h3 id="（三）存储容量"><a href="#（三）存储容量" class="headerlink" title="（三）存储容量"></a>（三）存储容量</h3><p>存储容量是指计算机存储二进制信息的总位数，它反映了计算机存储数据的能力。计算机的存储系统通常分为主存（内存）和辅存（外存），它们的容量衡量方式有所不同。</p>
<h4 id="3-3-1-主存容量"><a href="#3-3-1-主存容量" class="headerlink" title="3.3.1 主存容量"></a>3.3.1 主存容量</h4><p>主存容量的计算有两种方式：</p>
<ul>
<li><strong>存储单元个数 × 存储字长</strong>：存储单元是主存中存放一个字的基本单位，存储字长是每个存储单元所能存储的二进制位数。例如，当 MAR（地址寄存器）的位数为 10 位时，它能寻址的存储单元个数为2<sup>10</sup>=1 K，若 MDR（数据寄存器）的位数为 8 位（即存储字长为 8 位），那么主存容量就是1 K × 8 位；如果 MAR 位数为 16 位，MDR 位数为 32 位，那么存储单元个数为2<sup>16</sup>=64 K，主存容量就是64 K×32位。</li>
<li><strong>字节数</strong>：在计算机中，通常以字节（Byte，B）作为存储容量的基本单位，1 字节等于 8 位（1 B=2<sup>3</sup> b）。例如，2<sup>13</sup> b换算成字节的话，2<sup>13</sup>÷2<sup>3</sup>=2<sup>10</sup>=1024 B=1  KB；2<sup>21</sup> b=2<sup>21</sup>÷2<sup>3</sup>=2<sup>18</sup> B=256×2<sup>10&nbsp;</sup>B=256 KB。</li>
</ul>
<h4 id="3-3-2-辅存容量"><a href="#3-3-2-辅存容量" class="headerlink" title="3.3.2 辅存容量"></a>3.3.2 辅存容量</h4><p>辅存（如硬盘、固态硬盘等）的容量通常以字节数来衡量，常用的单位有 GB（吉字节）、TB（太字节）等。其中1 GB=2<sup>30</sup> B，例如一个 80 GB 的硬盘，其存储容量就是80×2<sup>30</sup> B。辅存的容量通常比主存大得多，用于长期存储大量的数据和程序。</p>
<h2 id="四、运算器探秘"><a href="#四、运算器探秘" class="headerlink" title="四、运算器探秘"></a>四、运算器探秘</h2><h3 id="（一）基本组成"><a href="#（一）基本组成" class="headerlink" title="（一）基本组成"></a>（一）基本组成</h3><p>运算器是计算机中执行算术运算和逻辑运算的部件，它的基本组成包括算术逻辑单元（ALU）、寄存器组和多路选择器等。我们可以用以下的字符图来示意运算器的基本结构：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">+-----------------+     +-----------------+</span><br><span class="line">|   寄存器组      |----&gt;|   多路选择器     |</span><br><span class="line">+-----------------+     +-----------------+</span><br><span class="line">                              |</span><br><span class="line">                              v</span><br><span class="line">+-----------------+     +-----------------+</span><br><span class="line">|   控制电路      |----&gt;|   ALU（算术逻辑单元）|</span><br><span class="line">+-----------------+     +-----------------+</span><br><span class="line">                              |</span><br><span class="line">                              v</span><br><span class="line">+-----------------+</span><br><span class="line">|   结果寄存器    |</span><br><span class="line">+-----------------+</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>算术逻辑单元（ALU）</strong>：是运算器的核心部件，负责执行各种算术运算（如加、减、乘、除等）和逻辑运算（如与、或、非、异或等）。ALU 的操作由控制信号控制，根据不同的控制信号，执行相应的运算操作。</li>
<li><strong>寄存器组</strong>：由多个寄存器组成，用于临时存放参与运算的数据和运算的中间结果。例如，通用寄存器可以存放操作数，累加器可以存放累加的结果等。寄存器的存取速度非常快，能够满足运算器高速运算的需求。</li>
<li><strong>多路选择器</strong>：用于从多个输入数据源中选择一个数据输入到 ALU 中。因为在运算过程中，可能有多个寄存器中的数据需要参与运算，多路选择器可以根据控制信号选择合适的数据。</li>
<li><strong>控制电路</strong>：产生控制 ALU、多路选择器以及寄存器组操作的控制信号，以协调运算器各部件之间的工作，确保运算操作按正确的顺序和方式进行。</li>
<li><strong>结果寄存器</strong>：用于存放 ALU 运算的结果，以便将结果传输到其他部件（如寄存器组或内存）。</li>
</ul>
<h3 id="（二）定点数运算"><a href="#（二）定点数运算" class="headerlink" title="（二）定点数运算"></a>（二）定点数运算</h3><p>定点数是指小数点位置固定的数，在计算机中通常有定点整数和定点小数两种表示形式。</p>
<h4 id="4-2-1-定点加法与减法运算"><a href="#4-2-1-定点加法与减法运算" class="headerlink" title="4.2.1 定点加法与减法运算"></a>4.2.1 定点加法与减法运算</h4><p>定点数的加法和减法运算可以通过补码来实现，这样可以将减法运算转换为加法运算，简化硬件设计。</p>
<ul>
<li><strong>补码加法</strong>：对于两个用补码表示的数 <em>X</em> 和 <em>Y</em>，它们的和的补码等于 <em>X</em> 的补码加上 <em>Y</em> 的补码，即[X + Y]<sub>补</sub> = [X]<sub>补</sub> + [Y]<sub>补</sub>（mod 2<sup>n</sup>，n 为字长）。</li>
<li><strong>补码减法</strong>：因为X − Y = X + (−Y)，所以[X - Y]<sub>补</sub> = [X]<sub>补</sub> + [-Y]<sub>补</sub>（mod 2<sup>n</sup>，n 为字长）。其中 [-Y]<sub>补</sub>是 [Y]<sub>补</sub>的变补（对 [Y]<sub>补</sub>按位取反，末位加 1）。</li>
</ul>
<p>例如，假设字长为 8 位，<em>X</em> = +5，其补码为00000101；<em>Y</em> = +3，其补码为00000011。则[X + Y]<sub>补</sub> = 00000101 + 00000011 = 00001000，对应的真值为+8，正确。再如，<em>X</em> = +5，<em>Y</em> = +3，<em>X</em> − <em>Y</em> = +2，[-Y]<sub>补</sub> = 11111101，[X]<sub>补</sub> + [-Y]<sub>补</sub> = 00000101 + 11111101 = 100000010，由于字长为 8 位，超出的位舍去，得到00000010，对应的真值为+2，正确。</p>
<h4 id="4-2-2-定点乘法运算"><a href="#4-2-2-定点乘法运算" class="headerlink" title="4.2.2 定点乘法运算"></a>4.2.2 定点乘法运算</h4><p>定点数的乘法运算有多种实现方法，这里介绍原码一位乘法（ booth 乘法的简化形式，适用于原码乘法）。原码一位乘法的运算过程是：根据乘数的每一位是 0 还是 1，决定是否将被乘数加到部分积上，然后将部分积右移一位，重复这个过程，直到乘数的每一位都处理完毕。</p>
<p>以原码表示的两位正数相乘为例，设被乘数<em>X</em>=0.1011（真值为0.6875），乘数<em>Y</em>=0.1101（真值为0.8125），乘积的真值应为0.6875×0.8125=0.55859375。</p>
<p>原码一位乘法的步骤如下（部分积初始为 0，乘数后面添加一位辅助位 0）：</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>部分积（初为 0）</th>
<th>乘数（<em>Y</em>）</th>
<th>辅助位</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>00.0000</td>
<td>0.1101 0</td>
<td>0</td>
<td>乘数末位与辅助位都是 0，部分积右移一位</td>
</tr>
<tr>
<td></td>
<td>00.0000</td>
<td>0.0110 1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>00.0000</td>
<td>0.0110 1</td>
<td>1</td>
<td>乘数末位是 1，辅助位是 0，部分积加被乘数00.1011，然后右移一位</td>
</tr>
<tr>
<td></td>
<td>00.1011</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>00.0101 1</td>
<td>0.0011 0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>00.0101 1</td>
<td>0.0011 0</td>
<td>1</td>
<td>乘数末位是 1，辅助位是 1，部分积加被乘数00.1011，然后右移一位</td>
</tr>
<tr>
<td></td>
<td>01.0000 1</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>00.1000 0 1</td>
<td>0.0001 1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>00.1000 0 1</td>
<td>0.0001 1</td>
<td>0</td>
<td>乘数末位是 0，辅助位是 1，部分积加 0（或减被乘数，这里因为是原码正数相乘，加 0 即可），然后右移一位</td>
</tr>
<tr>
<td></td>
<td>00.1000 0 1</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>00.0100 0 0 1</td>
<td>0.0000 1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>00.0100 0 0 1</td>
<td>0.0000 1</td>
<td>1</td>
<td>乘数末位是 1，辅助位是 0，部分积加被乘数00.1011，然后右移一位</td>
</tr>
<tr>
<td></td>
<td>00.1111 0 0 1</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>00.0111 1 0 0 1</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>最终的乘积为0.01111001，对应的真值为0.55859375，与预期结果一致。</p>
<h4 id="4-2-3-定点除法运算"><a href="#4-2-3-定点除法运算" class="headerlink" title="4.2.3 定点除法运算"></a>4.2.3 定点除法运算</h4><p>定点数的除法运算也有多种方法，这里介绍原码恢复余数法。原码恢复余数法的基本思想是：用被除数减去除数，若余数为正，表示够减，商上 1；若余数为负，表示不够减，商上 0，并将余数加上除数（恢复余数），然后将余数左移一位，重复上述过程，直到除尽或达到要求的精度。</p>
<p>以原码表示的两位正数相除为例，设被除数(X = 0.1011)（真值为(0.6875)），除数(Y = 0.1101)（真值为(0.8125)），商的真值应为(0.6875÷0.8125 = 0.846153846……)，这里我们取前几位有效位。</p>
<p>原码恢复余数法的步骤如下（余数初始为被除数的数值部分，除数为(0.1101)，商初始为 0）：</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>余数（初为(0.1011)）</th>
<th>除数（Y）</th>
<th>商</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>(0.1011)</td>
<td>(0.1101)</td>
<td>0</td>
<td>余数减除数：(0.1011 - 0.1101 = -0.0010)（余数为负），商上 0，恢复余数（加除数）：(-0.0010 + 0.1101 = 0.1011)，余数左移一位得(1.0110)</td>
</tr>
<tr>
<td>2</td>
<td>(1.0110)</td>
<td>(0.1101)</td>
<td>0</td>
<td>余数减除数：(1.0110 - 0.1101 = 0.1001)（余数为正），商上 1，余数左移一位得(1.0010)</td>
</tr>
<tr>
<td>3</td>
<td>(1.0010)</td>
<td>(0.1101)</td>
<td>1</td>
<td>余数减除数：(1.0010 - 0.1101 = 0.0101)（余数为正），商上 1，余数左移一位得(0.1010)</td>
</tr>
<tr>
<td>4</td>
<td>(0.1010)</td>
<td>(0.1101)</td>
<td>1</td>
<td>余数减除数：(0.1010 - 0.1101 = -0.0011)（余数为负），商上 0，恢复余数：(-0.0011 + 0.1101 = 0.1010)，余数左移一位得(1.0100)</td>
</tr>
<tr>
<td>5</td>
<td>(1.0100)</td>
<td>(0.1101)</td>
<td>10</td>
<td>余数减除数：(1.0100 - 0.1101 = 0.1111)（余数为正），商上 1，此时商为(0.1101)（前几位），对应的真值为(0.8125)，与实际商的近似值接近。</td>
</tr>
</tbody></table>
<h3 id="（三）浮点数运算"><a href="#（三）浮点数运算" class="headerlink" title="（三）浮点数运算"></a>（三）浮点数运算</h3><p>浮点数是指小数点位置不固定的数，它的表示形式为(N = S × r<sup>E</sup>)，其中S是尾数（表示数的有效数字），r是基数（通常为 2），E是阶码（表示小数点的位置）。浮点数运算相对定点数更复杂，主要包括对阶、尾数运算、规格化和舍入等步骤。</p>
<h4 id="4-3-1-对阶"><a href="#4-3-1-对阶" class="headerlink" title="4.3.1 对阶"></a>4.3.1 对阶</h4><p>对阶的目的是使两个浮点数的阶码相同，这样才能进行尾数的运算。对阶的原则是小阶向大阶看齐，即把阶码小的那个数的尾数右移，同时阶码加 1，直到两个数的阶码相等。右移尾数会导致尾数的有效数字减少，这是浮点数运算中误差的一个来源。</p>
<p>例如，有两个浮点数(A = 0.1011 × 2 <sup>01</sup>)，(B = 0.1101 × 2<sup>03</sup>)（阶码和尾数均为二进制表示）。A的阶码为01，B的阶码为03，A的阶码小。将A的尾数右移 2 位，变为(0.001011)，阶码加 2 变为03，此时(A = 0.001011 × 2<sup>03</sup>)，(B = 0.1101 × 2<sup>03</sup>)，阶码相同，可进行尾数运算。</p>
<h4 id="4-3-2-尾数运算"><a href="#4-3-2-尾数运算" class="headerlink" title="4.3.2 尾数运算"></a>4.3.2 尾数运算</h4><p>对阶完成后，进行尾数的加、减、乘、除等运算。尾数的运算与定点数的运算类似，这里以加法为例。</p>
<p>承接上面的例子，A和B尾数相加：(0.001011 + 0.1101 = 0.111111)，所以(A + B = 0.111111×2<sup>03</sup>)。</p>
<h4 id="4-3-3-规格化"><a href="#4-3-3-规格化" class="headerlink" title="4.3.3 规格化"></a>4.3.3 规格化</h4><p>规格化的目的是使尾数的形式符合规定的标准，以提高浮点数的表示精度。对于基数为 2 的浮点数，规格化的尾数应满足(0.5 ≤ |S| &lt; 1)（原码表示）或(-1 &lt; S ≤ -0.5)、(0.5 ≤ S &lt; 1)（补码表示）。如果尾数不符合规格化要求，需要通过左移或右移尾数，并相应地调整阶码来实现规格化。</p>
<p>例如，若尾数为(0.011111)，不满足规格化要求（因为(0.011111 &lt; 0.5)），需要将尾数左移 1 位变为(0.111110)，同时阶码减 1，这样就实现了规格化。</p>
<h4 id="4-3-4-舍入"><a href="#4-3-4-舍入" class="headerlink" title="4.3.4 舍入"></a>4.3.4 舍入</h4><p>在对阶和规格化过程中，尾数可能会被右移，导致部分有效数字丢失。舍入就是为了处理这种情况，尽量减少误差。常见的舍入方法有截断法、0 舍 1 入法等。截断法是直接舍去多余的位，这种方法简单但误差较大；0 舍 1 入法类似于十进制的四舍五入，当要舍去的最高位为 1 时，向尾数的末位进 1，否则舍去，这种方法的误差相对较小。</p>
<h2 id="五、存储器系统"><a href="#五、存储器系统" class="headerlink" title="五、存储器系统"></a>五、存储器系统</h2><h3 id="（一）层次结构-1"><a href="#（一）层次结构-1" class="headerlink" title="（一）层次结构"></a>（一）层次结构</h3><p>为了平衡存储容量、存取速度和成本之间的关系，计算机采用了层次化的存储结构，从高速到低速、从容量小到容量大依次为：寄存器组、高速缓冲存储器（Cache）、主存储器（内存）、辅助存储器（外存）。我们可以用字符图来表示：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">+-----------------+     +-----------------+</span><br><span class="line">|   寄存器组      |&lt;----&gt;|   Cache         |</span><br><span class="line">+-----------------+     +-----------------+</span><br><span class="line">                              |</span><br><span class="line">                              v</span><br><span class="line">+-----------------+     +-----------------+</span><br><span class="line">|   主存（内存）   |&lt;----&gt;|   辅存（外存）   |</span><br><span class="line">+-----------------+     +-----------------+</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>寄存器组</strong>：位于 CPU 内部，存取速度最快，但容量极小，主要用于临时存放 CPU 正在处理的数据。</li>
<li><strong>高速缓冲存储器（Cache）</strong>：介于 CPU 和主存之间，速度接近寄存器组，容量比寄存器组大，但比主存小。它的作用是缓存 CPU 即将访问的主存数据，减少 CPU 访问主存的次数，从而提高系统性能。因为 CPU 访问 Cache 的速度比访问主存快得多。</li>
<li><strong>主存储器（内存）</strong>：是计算机的主要存储部件，CPU 可以直接访问。它的速度比 Cache 慢，但容量比 Cache 大，用于存放当前正在运行的程序和数据。</li>
<li><strong>辅助存储器（外存）</strong>：如硬盘、固态硬盘、光盘等，容量很大，但存取速度较慢。主要用于长期存储程序、数据和文件等，CPU 不能直接访问外存，需要通过输入 / 输出操作将数据调入主存后才能被 CPU 访问。</li>
</ul>
<h3 id="（二）主存储器"><a href="#（二）主存储器" class="headerlink" title="（二）主存储器"></a>（二）主存储器</h3><p>主存储器通常由半导体存储器组成，按读写方式可分为随机存取存储器（RAM）和只读存储器（ROM）。</p>
<h4 id="5-2-1-随机存取存储器（RAM）"><a href="#5-2-1-随机存取存储器（RAM）" class="headerlink" title="5.2.1 随机存取存储器（RAM）"></a>5.2.1 随机存取存储器（RAM）</h4><p>RAM 可以随机地对任意存储单元进行读写操作，存取时间与存储单元的位置无关。根据存储单元的工作原理，RAM 又可分为静态 RAM（SRAM）和动态 RAM（DRAM）。</p>
<ul>
<li><strong>静态 RAM（SRAM）</strong>：利用触发器的状态来存储信息，只要电源不断，信息就不会丢失。SRAM 的存取速度快，但集成度低、功耗大、成本高，主要用于 Cache。</li>
<li><strong>动态 RAM（DRAM）</strong>：利用电容存储电荷的原理来存储信息，由于电容会漏电，所以需要定期刷新（每隔一定时间对电容进行充电，补充电荷），否则信息会丢失。DRAM 的集成度高、功耗低、成本低，但存取速度比 SRAM 慢，主要用于主存。</li>
</ul>
<h4 id="5-2-2-只读存储器（ROM）"><a href="#5-2-2-只读存储器（ROM）" class="headerlink" title="5.2.2 只读存储器（ROM）"></a>5.2.2 只读存储器（ROM）</h4><p>ROM 在正常工作时只能读出信息，不能写入信息，信息一旦写入就固定不变，断电后信息也不会丢失。ROM 常用于存储计算机的基本输入输出系统（BIOS）等固定程序和数据。随着技术的发展，出现了可擦除可编程 ROM（EPROM）、电可擦除可编程 ROM（EEPROM）和闪存（Flash Memory）等，这些类型的 ROM 可以在一定条件下进行写入操作。</p>
<h3 id="（三）存储器扩展"><a href="#（三）存储器扩展" class="headerlink" title="（三）存储器扩展"></a>（三）存储器扩展</h3><p>当单个存储器芯片的容量或字长不能满足需求时，需要进行存储器的扩展，主要有位扩展、字扩展和字位同时扩展三种方式。</p>
<h4 id="5-3-1-位扩展"><a href="#5-3-1-位扩展" class="headerlink" title="5.3.1 位扩展"></a>5.3.1 位扩展</h4><p>位扩展用于增加存储器的字长。例如，现有若干片容量为(1K×4)位的 RAM 芯片，要组成(1K×8)位的存储器。因为字长需要从 4 位扩展到 8 位，所以需要 2 片这样的芯片，将它们的地址线、片选线分别并联，数据线分别作为高 4 位和低 4 位，这样就实现了位扩展。</p>
<h4 id="5-3-2-字扩展"><a href="#5-3-2-字扩展" class="headerlink" title="5.3.2 字扩展"></a>5.3.2 字扩展</h4><p>字扩展用于增加存储器的容量（字数）。例如，现有若干片容量为(1K×8)位的 RAM 芯片，要组成(2K×8)位的存储器。因为字数需要从 1K 扩展到 2K，所以需要 2 片这样的芯片。将它们的数据线并联，地址线增加一位（用于选择芯片），片选线分别由地址线的新增位控制，这样就实现了字扩展。</p>
<h4 id="5-3-3-字位同时扩展"><a href="#5-3-3-字位同时扩展" class="headerlink" title="5.3.3 字位同时扩展"></a>5.3.3 字位同时扩展</h4><p>当既需要增加字长又需要增加字数时，就需要进行字位同时扩展。例如，用(1K×4)位的 RAM 芯片组成(2K×8)位的存储器，需要 4 片这样的芯片。首先进行位扩展，用 2 片组成(1K×8)位的组；然后进行字扩展，用 2 组这样的组组成(2K×8)位的存储器，地址线增加一位用于选择组，片选线分别由地址线的新增位控制每组的芯片。</p>
<h3 id="（四）高速缓冲存储器"><a href="#（四）高速缓冲存储器" class="headerlink" title="（四）高速缓冲存储器"></a>（四）高速缓冲存储器</h3><h4 id="5-4-1-Cache-的工作原理"><a href="#5-4-1-Cache-的工作原理" class="headerlink" title="5.4.1 Cache 的工作原理"></a>5.4.1 Cache 的工作原理</h4><p>Cache 的工作基于程序访问的局部性原理，即程序在执行过程中，往往会频繁访问某些局部的内存区域，如循环指令、数组数据等。Cache 就是将这些即将被访问的内存数据复制到 Cache 中，当 CPU 需要访问这些数据时，首先在 Cache 中查找，如果找到（命中），就直接从 Cache 中读取，速度很快；如果没找到（缺失），就从主存中读取，并将读取的数据块调入 Cache 中，以便后续访问。</p>
<h4 id="5-4-2-Cache-的映射方式"><a href="#5-4-2-Cache-的映射方式" class="headerlink" title="5.4.2 Cache 的映射方式"></a>5.4.2 Cache 的映射方式</h4><p>Cache 的映射方式决定了主存中的数据块如何映射到 Cache 中，主要有直接映射、全相联映射和组相联映射三种。</p>
<ul>
<li><strong>直接映射</strong>：主存中的每个数据块只能映射到 Cache 中一个特定的块位置。映射公式为：(Cache 块号 = 主存块号 mod Cache 块数)。直接映射的优点是实现简单，速度快；缺点是 Cache 的利用率低，容易发生冲突（不同的主存块映射到同一个 Cache 块，导致其中一个块被替换）。</li>
<li><strong>全相联映射</strong>：主存中的每个数据块可以映射到 Cache 中的任意一个块位置。这种映射方式的优点是 Cache 的利用率高，冲突率低；缺点是实现复杂，需要硬件的相联存储器来进行地址比较，速度较慢。</li>
<li><strong>组相联映射</strong>：是直接映射和全相联映射的折中。将 Cache 分为若干组，每组包含若干块。主存中的每个数据块映射到 Cache 中特定组的任意一个块位置。映射公式为：(组号 = 主存块号 mod 组数)。组相联映射的性能介于直接映射和全相联映射之间，在实际中应用广泛。</li>
</ul>
<h4 id="5-4-3-Cache-的替换策略"><a href="#5-4-3-Cache-的替换策略" class="headerlink" title="5.4.3 Cache 的替换策略"></a>5.4.3 Cache 的替换策略</h4><p>当 Cache 发生缺失，需要调入主存数据块而 Cache 又满时，需要选择一个 Cache 块进行替换。常见的替换策略有：</p>
<ul>
<li><strong>随机替换策略</strong>：随机选择一个 Cache 块进行替换。这种策略实现简单，但可能会替换掉即将被访问的块，导致较高的缺失率。</li>
<li><strong>先进先出（FIFO）策略</strong>：选择最早进入 Cache 的块进行替换。按照进入 Cache 的先后顺序进行替换，实现也比较简单，但也不能很好地适应程序的局部性。</li>
<li><strong>最近最少使用（LRU）策略</strong>：选择最长时间没有被访问的块进行替换。这种策略能较好地利用程序的局部性，因为最近最少使用的块很可能在未来较长时间内也不会被访问，所以缺失率较低，但实现相对复杂，需要记录每个块的访问时间。</li>
</ul>
<h2 id="六、控制器"><a href="#六、控制器" class="headerlink" title="六、控制器"></a>六、控制器</h2><h3 id="（一）基本组成-1"><a href="#（一）基本组成-1" class="headerlink" title="（一）基本组成"></a>（一）基本组成</h3><p>控制器是计算机的指挥中心，负责控制计算机各部件的协调工作，它的基本组成包括程序计数器（PC）、指令寄存器（IR）、指令译码器（ID）、时序产生器和操作控制器等。用字符图示意如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">+-----------------+     +-----------------+</span><br><span class="line">|   程序计数器（PC）|----&gt;|   指令寄存器（IR）|</span><br><span class="line">+-----------------+     +-----------------+</span><br><span class="line">                              |</span><br><span class="line">                              v</span><br><span class="line">+-----------------+     +-----------------+</span><br><span class="line">|   指令译码器（ID）|----&gt;|   时序产生器    |</span><br><span class="line">+-----------------+     +-----------------+</span><br><span class="line">                              |</span><br><span class="line">                              v</span><br><span class="line">+-----------------+</span><br><span class="line">| 操作控制器      |</span><br><span class="line">+-----------------+</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>程序计数器（PC）</strong>：用于存放下一条要执行的指令的地址。在程序执行过程中，PC 会自动递增（指向下一条指令的地址），从而保证程序按顺序执行。如果遇到转移指令，PC 会被设置为转移目标地址。</li>
<li><strong>指令寄存器（IR）</strong>：用于存放当前正在执行的指令。从主存中取出的指令会先送入 IR 中，以便进行后续的译码和执行操作。</li>
<li><strong>指令译码器（ID）</strong>：对 IR 中的指令进行译码，分析出指令的操作码和地址码等信息，从而确定该指令要执行的操作以及操作数的地址。</li>
<li><strong>时序产生器</strong>：产生计算机工作所需的时序信号，如时钟周期、机器周期等。这些时序信号用于控制各部件操作的时间顺序，确保计算机各部件能协调一致地工作。</li>
<li><strong>操作控制器</strong>：根据指令译码的结果和时序信号，产生控制各部件（如运算器、存储器、I/O 设备等）操作的控制信号，指挥各部件完成指令规定的操作。</li>
</ul>
<h3 id="（二）指令周期"><a href="#（二）指令周期" class="headerlink" title="（二）指令周期"></a>（二）指令周期</h3><p>指令周期是指从取指令开始到执行完该指令所需的全部时间。不同的指令，其指令周期可能不同，因为不同的指令执行的操作不同，所需的时间也不同。一个指令周期通常由若干个机器周期（CPU 周期）组成，而一个机器周期又由若干个时钟周期（节拍）组成。</p>
<h4 id="6-2-1-取指周期"><a href="#6-2-1-取指周期" class="headerlink" title="6.2.1 取指周期"></a>6.2.1 取指周期</h4><p>取指周期是指令周期的第一个阶段，主要完成从主存中取出指令的操作。具体步骤如下：</p>
<ol>
<li>将程序计数器（PC）中的指令地址送到地址总线上，向主存发出读命令。</li>
<li>主存根据地址取出相应的指令，并通过数据总线送到指令寄存器（IR）中。</li>
<li>PC 自动递增，为取下一条指令做好准备。</li>
</ol>
<h4 id="6-2-2-间址周期（若需要）"><a href="#6-2-2-间址周期（若需要）" class="headerlink" title="6.2.2 间址周期（若需要）"></a>6.2.2 间址周期（若需要）</h4><p>如果指令是间接寻址指令，在取指周期之后会进入间址周期，用于取出操作数的有效地址。步骤如下：</p>
<ol>
<li>将 IR 中指令的地址码部分（形式地址）送到地址总线上，向主存发出读命令。</li>
<li>主存取出形式地址对应的存储单元中的内容，即操作数的有效地址，送到 IR 的地址码字段（或其他指定寄存器）。</li>
</ol>
<h4 id="6-2-3-执行周期"><a href="#6-2-3-执行周期" class="headerlink" title="6.2.3 执行周期"></a>6.2.3 执行周期</h4><p>执行周期是指令周期的核心阶段，根据指令译码的结果，由操作控制器产生相应的控制信号，指挥各部件执行指令规定的操作。不同类型的指令，执行周期的操作差异很大：</p>
<ul>
<li><strong>算术逻辑运算指令</strong>：操作控制器控制运算器从寄存器或主存中取出操作数，进行相应的算术或逻辑运算，然后将结果存回寄存器或主存。</li>
<li><strong>访存指令（如读、写内存指令）</strong>：对于读内存指令，控制主存根据地址取出数据并送到指定寄存器；对于写内存指令，控制将指定寄存器中的数据写入主存的指定地址。</li>
<li><strong>转移指令</strong>：根据指令的条件判断结果，将程序计数器（PC）设置为转移目标地址，从而改变程序的执行顺序。</li>
</ul>
<h4 id="6-2-4-中断周期（若发生中断）"><a href="#6-2-4-中断周期（若发生中断）" class="headerlink" title="6.2.4 中断周期（若发生中断）"></a>6.2.4 中断周期（若发生中断）</h4><p>在指令执行过程中，若出现中断请求（如 I/O 设备请求、时钟中断等），且满足中断响应条件，会进入中断周期。主要操作包括：</p>
<ol>
<li>保存断点：将当前 PC 的内容（下一条要执行的指令地址）压入堆栈或特定的内存单元，以便中断处理完成后能返回断点继续执行。</li>
<li>将 PC 设置为中断服务程序的入口地址，开始执行中断服务程序。</li>
</ol>
<h3 id="（三）控制方式"><a href="#（三）控制方式" class="headerlink" title="（三）控制方式"></a>（三）控制方式</h3><p>控制器的控制方式主要有同步控制、异步控制和联合控制三种。</p>
<h4 id="6-3-1-同步控制"><a href="#6-3-1-同步控制" class="headerlink" title="6.3.1 同步控制"></a>6.3.1 同步控制</h4><p>同步控制方式是指计算机的各个操作由统一的时序信号（如时钟信号）控制。在同步控制下，每个机器周期的长度是固定的，每个操作的开始和结束都由时钟信号的上升沿或下降沿严格定时。这种控制方式的优点是控制简单，各部件之间的协调容易；缺点是不管操作是否需要，都要等待时钟周期的结束，可能会造成时间的浪费，降低系统的效率。</p>
<h4 id="6-3-2-异步控制"><a href="#6-3-2-异步控制" class="headerlink" title="6.3.2 异步控制"></a>6.3.2 异步控制</h4><p>异步控制方式是指各个操作之间没有统一的时钟周期，而是通过应答信号（握手信号）来协调。当一个部件完成操作后，会向另一个部件发出完成信号，另一个部件收到信号后再开始自己的操作。这种控制方式的优点是能根据操作的实际需要分配时间，提高系统的效率；缺点是控制逻辑复杂，需要较多的应答线路。</p>
<h4 id="6-3-3-联合控制"><a href="#6-3-3-联合控制" class="headerlink" title="6.3.3 联合控制"></a>6.3.3 联合控制</h4><p>联合控制方式是同步控制和异步控制的结合。对于大部分操作采用同步控制，以简化控制逻辑；对于某些特殊操作（如 I/O 操作，其时间不确定）采用异步控制，以提高效率。这种控制方式兼顾了同步控制和异步控制的优点，在现代计算机中应用广泛。</p>
<h3 id="（四）微程序控制器"><a href="#（四）微程序控制器" class="headerlink" title="（四）微程序控制器"></a>（四）微程序控制器</h3><p>微程序控制器是一种用微程序来控制指令执行的控制器。它将每条机器指令转换为一段微程序，微程序由若干条微指令组成，每条微指令对应一个或多个微操作。</p>
<h4 id="6-4-1-微程序控制器的组成"><a href="#6-4-1-微程序控制器的组成" class="headerlink" title="6.4.1 微程序控制器的组成"></a>6.4.1 微程序控制器的组成</h4><p>微程序控制器主要由控制存储器（CM）、微指令寄存器（μIR）、微地址形成部件和微地址寄存器（μAR）等组成。</p>
<ul>
<li><strong>控制存储器（CM）</strong>：用于存放微程序，是一种只读存储器（通常为 ROM），其容量取决于微程序的数量和每条微指令的长度。</li>
<li><strong>微指令寄存器（μIR）</strong>：用于存放从控制存储器中读出的微指令，微指令包含操作控制字段（控制各个微操作的执行）和顺序控制字段（控制下一条微指令的地址）。</li>
<li><strong>微地址形成部件</strong>：根据当前微指令的顺序控制字段、指令的操作码以及其他条件（如状态标志），形成下一条微指令的地址。</li>
<li><strong>微地址寄存器（μAR）</strong>：用于存放即将访问的控制存储器的地址（微地址）。</li>
</ul>
<h4 id="6-4-2-微程序的执行过程"><a href="#6-4-2-微程序的执行过程" class="headerlink" title="6.4.2 微程序的执行过程"></a>6.4.2 微程序的执行过程</h4><p>以执行一条机器指令为例，微程序的执行过程如下：</p>
<ol>
<li>取机器指令：从主存中取出机器指令，送入指令寄存器（IR）。</li>
<li>生成微程序入口地址：根据 IR 中的操作码，由微地址形成部件生成该机器指令对应的微程序的入口地址，送入微地址寄存器（μAR）。</li>
<li>读取微指令：根据 μAR 中的地址，从控制存储器（CM）中读出对应的微指令，送入微指令寄存器（μIR）。</li>
<li>执行微指令：由 μIR 中的操作控制字段产生控制信号，控制各部件执行相应的微操作；同时，由顺序控制字段和其他条件，形成下一条微指令的地址，送入 μAR。</li>
<li>重复步骤 3 和 4，直到该微程序执行完毕，完成机器指令的执行。</li>
</ol>
<h4 id="6-4-3-微指令的编码方式"><a href="#6-4-3-微指令的编码方式" class="headerlink" title="6.4.3 微指令的编码方式"></a>6.4.3 微指令的编码方式</h4><p>微指令的编码方式主要有直接编码、字段直接编码和字段间接编码等，用于减少微指令的长度。</p>
<ul>
<li><strong>直接编码</strong>：每个微操作对应微指令中的一位，位为 1 表示执行该微操作，位为 0 表示不执行。这种编码方式的优点是简单直观，控制速度快；缺点是微指令的长度很长，控制存储器的容量大。</li>
<li><strong>字段直接编码</strong>：将微指令的操作控制字段分成若干个字段，每个字段中的若干位表示一组互斥的微操作（即同一时刻该组中只能有一个微操作被执行）。通过字段编码，可以大大缩短微指令的长度。例如，一个字段有 3 位，可以表示(2^3 = 8)个互斥的微操作。</li>
<li><strong>字段间接编码</strong>：一个字段的编码不仅取决于本身的位，还取决于其他字段的编码。这种编码方式可以进一步缩短微指令的长度，但控制逻辑更复杂。</li>
</ul>
<h2 id="七、输入输出系统"><a href="#七、输入输出系统" class="headerlink" title="七、输入输出系统"></a>七、输入输出系统</h2><h3 id="（一）I-O-设备"><a href="#（一）I-O-设备" class="headerlink" title="（一）I/O 设备"></a>（一）I/O 设备</h3><p>输入输出设备（I/O 设备）是计算机与外部世界进行交互的桥梁，包括输入设备（如键盘、鼠标、扫描仪等）和输出设备（如显示器、打印机、绘图仪等）。</p>
<h4 id="7-1-1-输入设备"><a href="#7-1-1-输入设备" class="headerlink" title="7.1.1 输入设备"></a>7.1.1 输入设备</h4><p>输入设备的作用是将外部的信息（如字符、图像、声音等）转换为计算机能识别的二进制数据，输入到计算机中。</p>
<ul>
<li><strong>键盘</strong>：是最常用的输入设备之一，通过按键将字符信息输入到计算机。键盘的工作原理是当按下一个键时，产生对应的扫描码，然后将扫描码转换为 ASCII 码或其他编码，送入计算机。</li>
<li><strong>鼠标</strong>：用于在图形界面中进行定位和操作，通过检测鼠标的移动和按键动作，将位置信息和操作指令输入到计算机。鼠标有机械鼠标、光电鼠标等类型。</li>
<li><strong>扫描仪</strong>：用于将纸质文档、图片等转换为数字图像输入到计算机。扫描仪通过光学扫描原理，将图像的光信号转换为电信号，再经过模数转换得到数字图像数据。</li>
</ul>
<h4 id="7-1-2-输出设备"><a href="#7-1-2-输出设备" class="headerlink" title="7.1.2 输出设备"></a>7.1.2 输出设备</h4><p>输出设备的作用是将计算机处理后的二进制数据转换为人类能识别的形式（如字符、图像、声音等）输出。</p>
<ul>
<li><strong>显示器</strong>：是计算机最主要的输出设备，用于显示文字、图像、视频等信息。显示器的类型主要有阴极射线管（CRT）显示器、液晶显示器（LCD）、有机发光二极管（OLED）显示器等。显示器的显示原理是通过控制像素的发光来形成图像，像素由红、绿、蓝三种颜色的子像素组成。</li>
<li><strong>打印机</strong>：用于将计算机中的文档、图像等打印到纸张上。打印机的类型有针式打印机、喷墨打印机和激光打印机等。针式打印机通过打印针击打色带，在纸上形成字符或图形；喷墨打印机通过喷头将墨水喷到纸上；激光打印机利用激光扫描和碳粉吸附原理进行打印。</li>
</ul>
<h3 id="（二）I-O-接口"><a href="#（二）I-O-接口" class="headerlink" title="（二）I/O 接口"></a>（二）I/O 接口</h3><p>I/O 接口是计算机主机与 I/O 设备之间的连接部件，它为 I/O 设备提供了与主机通信的通道，解决了主机与 I/O 设备之间在速度、时序、格式等方面的差异。</p>
<h4 id="7-2-1-I-O-接口的功能"><a href="#7-2-1-I-O-接口的功能" class="headerlink" title="7.2.1 I/O 接口的功能"></a>7.2.1 I/O 接口的功能</h4><p>I/O 接口主要有以下功能：</p>
<ul>
<li><strong>数据缓冲</strong>：设置数据缓冲寄存器，用于暂时存放主机与 I/O 设备之间传输的数据，解决主机与 I/O 设备之间速度不匹配的问题。</li>
<li><strong>格式转换</strong>：实现不同数据格式之间的转换，如串行数据与并行数据之间的转换。</li>
<li><strong>电平转换</strong>：有些 I/O 设备的信号电平与主机不同，I/O 接口需要进行电平转换，使两者的电平兼容。</li>
<li><strong>地址译码</strong>：对主机发出的地址进行译码，选择对应的 I/O 设备。</li>
<li><strong>控制信号转换</strong>：将主机的控制信号转换为 I/O 设备能识别的控制信号，或者将 I/O 设备的状态信号转换为主机能识别的信号。</li>
</ul>
<h4 id="7-2-2-I-O-接口的分类"><a href="#7-2-2-I-O-接口的分类" class="headerlink" title="7.2.2 I/O 接口的分类"></a>7.2.2 I/O 接口的分类</h4><p>根据数据传输方式，I/O 接口可分为串行接口和并行接口；根据是否可编程，可分为可编程接口和不可编程接口。</p>
<ul>
<li><strong>串行接口与并行接口</strong>：串行接口一次只传输一位数据，数据传输线少，适用于远距离传输，但传输速度较慢；并行接口一次传输多位数据（通常为 8 位、16 位或 32 位），传输速度快，但数据传输线多，适用于近距离传输。</li>
<li><strong>可编程接口与不可编程接口</strong>：可编程接口的工作方式可以通过程序进行设置，具有较大的灵活性，如 Intel 8255A 可编程并行接口芯片；不可编程接口的工作方式固定，不能通过程序改变，功能相对简单。</li>
</ul>
<h3 id="（三）I-O-控制方式"><a href="#（三）I-O-控制方式" class="headerlink" title="（三）I/O 控制方式"></a>（三）I/O 控制方式</h3><p>I/O 控制方式决定了主机与 I/O 设备之间数据传输的控制方式，主要有程序查询方式、中断控制方式、直接存储器访问（DMA）方式和通道方式等。</p>
<h4 id="7-3-1-程序查询方式"><a href="#7-3-1-程序查询方式" class="headerlink" title="7.3.1 程序查询方式"></a>7.3.1 程序查询方式</h4><p>程序查询方式是指 CPU 通过执行程序不断查询 I/O 设备的状态，当 I/O 设备准备好时，才进行数据传输。具体步骤如下：</p>
<ol>
<li>CPU 向 I/O 设备发出查询命令，请求获取设备状态。</li>
<li>I/O 设备返回状态信息，CPU 读取该状态信息。</li>
<li>CPU 检查状态信息，判断 I/O 设备是否准备好。如果未准备好，重复步骤 1 - 3；如果准备好，进行数据传输。</li>
</ol>
<p>程序查询方式的优点是控制简单，不需要额外的硬件支持；缺点是 CPU 需要不断查询 I/O 设备的状态，占用了 CPU 大量的时间，导致 CPU 的效率很低，尤其是在 I/O 设备较多或传输数据量较大时，这种方式的性能很差。</p>
<h4 id="7-3-2-中断控制方式"><a href="#7-3-2-中断控制方式" class="headerlink" title="7.3.2 中断控制方式"></a>7.3.2 中断控制方式</h4><p>中断控制方式是指当 I/O 设备准备好时，主动向 CPU 发出中断请求，CPU 在执行完当前指令后，响应中断请求，暂停正在执行的程序，转去执行中断服务程序（进行数据传输等操作），完成后再返回继续执行原来的程序。</p>
<p>中断控制方式的优点是 CPU 不需要主动查询 I/O 设备的状态，只有在 I/O 设备发出中断请求时才进行处理，提高了 CPU 的效率；缺点是每次中断都需要保存和恢复 CPU 的现场（如寄存器内容、程序计数器等），需要一定的 overhead，并且对于高速 I/O 设备或大量数据传输，可能会因为中断次数过多而影响系统性能。</p>
<h4 id="7-3-3-直接存储器访问（DMA）方式"><a href="#7-3-3-直接存储器访问（DMA）方式" class="headerlink" title="7.3.3 直接存储器访问（DMA）方式"></a>7.3.3 直接存储器访问（DMA）方式</h4><p>DMA 方式是一种在 DMA 控制器（DMAC）的控制下，直接在 I/O 设备和主存之间进行数据传输的方式，不需要 CPU 的干预。具体步骤如下：</p>
<ol>
<li>I/O 设备准备好数据后，向 DMAC 发出 DMA 请求。</li>
<li>DMAC 向 CPU 发出总线请求，请求占用总线。</li>
<li>CPU 在允许的情况下，释放总线控制权，将总线交给 DMAC。</li>
<li>DMAC 控制 I/O 设备和主存之间进行数据传输，传输完成后，DMAC 向 CPU 发出总线释放信号，CPU 重新获得总线控制权。</li>
</ol>
<p>DMA 方式的优点是数据传输速度快，因为不需要 CPU 的干预，减少了 CPU 的 overhead；缺点是需要专用的 DMA 控制器，增加了硬件成本，并且 DMAC 的编程相对复杂。DMA 方式适用于高速 I/O 设备（如磁盘、高速网络接口等）与主存之间的大量数据传输。</p>
<h4 id="7-3-4-通道方式"><a href="#7-3-4-通道方式" class="headerlink" title="7.3.4 通道方式"></a>7.3.4 通道方式</h4><p>通道是一种专门用于控制 I/O 设备与主存之间数据传输的处理机，它具有自己的指令系统（通道指令），可以独立地执行通道程序，控制 I/O 设备的操作。</p>
<p>通道方式的工作过程如下：</p>
<ol>
<li>CPU 将通道程序的起始地址和要传输的数据数量等信息送入通道。</li>
<li>通道执行通道程序，控制 I/O 设备与主存之间进行数据传输。</li>
<li>传输完成后，通道向 CPU 发出中断请求，CPU 进行相应的处理。</li>
</ol>
<p>通道方式的优点是可以同时控制多个 I/O 设备，提高了系统的 I/O 能力和 CPU 的效率；缺点是通道的结构复杂，成本高。通道方式主要用于大型计算机系统中。</p>
<h2 id="八、系统性能与发展"><a href="#八、系统性能与发展" class="headerlink" title="八、系统性能与发展"></a>八、系统性能与发展</h2><h3 id="（一）性能评价"><a href="#（一）性能评价" class="headerlink" title="（一）性能评价"></a>（一）性能评价</h3><p>计算机系统的性能是一个综合的指标，涉及多个方面，如运算速度、存储容量、I/O 吞吐量、可靠性、可用性等。对计算机系统性能的评价需要采用科学的方法，常用的性能评价方法有基准程序法、模型法等。</p>
<h4 id="8-1-1-基准程序法"><a href="#8-1-1-基准程序法" class="headerlink" title="8.1.1 基准程序法"></a>8.1.1 基准程序法</h4><p>基准程序法是通过运行一组标准的程序（基准程序）来测试计算机系统的性能。基准程序应具有代表性，能够反映计算机在实际应用中的性能。常见的基准程序有 SPEC（Standard Performance Evaluation Corporation）基准程序、Dhrystone 基准程序（测试整数性能）、Linpack 基准程序（测试浮点性能）等。</p>
<p>通过在不同的计算机系统上运行相同的基准程序，比较它们的运行时间、吞吐量等指标，从而评价计算机系统的性能。这种方法的优点是直观、实际，能较好地反映计算机在实际应用中的性能；缺点是基准程序的选择会影响评价结果，不同的基准程序可能会得出不同的性能排名。</p>
<h4 id="8-1-2-模型法"><a href="#8-1-2-模型法" class="headerlink" title="8.1.2 模型法"></a>8.1.2 模型法</h4><p>模型法是通过建立计算机系统的性能模型，来评价计算机系统的性能。性能模型可以是解析模型（用数学公式描述系统性能）或模拟模型（通过模拟计算机系统的运行来评价性能）。</p>
<p>解析模型的优点是简洁、计算方便；缺点是对复杂系统的建模难度大，模型的准确性可能受到限制。模拟模型的优点是可以模拟复杂的系统行为，准确性较高；缺点是模拟过程耗时，需要大量的计算资源。</p>
<h3 id="（二）发展趋势"><a href="#（二）发展趋势" class="headerlink" title="（二）发展趋势"></a>（二）发展趋势</h3><p>随着技术的不断进步，计算机系统呈现出以下发展趋势：</p>
<h4 id="8-2-1-高性能化"><a href="#8-2-1-高性能化" class="headerlink" title="8.2.1 高性能化"></a>8.2.1 高性能化</h4><p>计算机的运算速度、存储容量等性能指标不断提高。在处理器方面，通过提高主频、增加核心数、采用多线程技术、发展异构计算（如 CPU 与 GPU、FPGA 等协同计算）等方式，不断提升计算性能；在存储方面，主存的容量和速度不断提高，辅存的容量也在不断扩大，同时新型存储技术（如非易失性内存、3D 存储等）的发展，也在改善存储系统的性能。</p>
<h4 id="8-2-2-微型化与便携化"><a href="#8-2-2-微型化与便携化" class="headerlink" title="8.2.2 微型化与便携化"></a>8.2.2 微型化与便携化</h4><p>计算机的体积越来越小，便携性越来越强。从早期的大型计算机，到后来的小型计算机、个人计算机，再到现在的笔记本电脑、平板电脑、智能手机等，计算机的微型化和便携化趋势非常明显。这得益于集成电路技术的发展，使得更多的功能可以集成到更小的芯片上。</p>
<h4 id="8-2-3-网络化与智能化"><a href="#8-2-3-网络化与智能化" class="headerlink" title="8.2.3 网络化与智能化"></a>8.2.3 网络化与智能化</h4><p>计算机与网络的结合越来越紧密，网络化已经成为计算机系统的重要特征。通过网络，计算机可以实现资源共享、远程通信、分布式计算等功能。同时，人工智能技术的发展也推动了计算机系统的智能化，计算机能够进行更复杂的模式识别、推理、学习等智能操作，在图像识别、自然语言处理、自动驾驶等领域得到广泛应用。</p>
<h4 id="8-2-4-节能"><a href="#8-2-4-节能" class="headerlink" title="8.2.4 节能"></a>8.2.4 节能</h4><p>随着能源问题的日益突出，计算机系统的绿色节能成为重要的发展趋势。通过采用低功耗的硬件组件、优化系统的电源管理、提高能源利用效率等方式，减少计算机系统的能源消耗和散热需求，实现绿色计算。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>计算机组成原理是计算机科学与技术的基石，它涵盖了从硬件底层到系统架构的丰富知识。通过对运算器、存储器、控制器、输入输出系统等核心组件的深入学习，我们能够理解计算机是如何高效地执行指令、处理数据的。</p>
<p>计算机技术在不断发展，新的架构、新的存储技术、新的 I/O 方式等不断涌现，但计算机组成原理的核心思想和基本原理始终是理解这些新技术的关键。希望通过本文的阐述，我们能更深入地认识计算机系统，在计算机的世界里不断探索和进步。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://lvjia.netlify.app">lvting.chi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://lvjia.netlify.app/2-ji-suan-ji-zu-cheng-yuan-li-gai-shu/">http://lvjia.netlify.app/2-ji-suan-ji-zu-cheng-yuan-li-gai-shu/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://lvjia.netlify.app" target="_blank">Lvjia</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/3-ji-suan-ji-zu-cheng-yuan-li-zong-xian-gai-shu/" title="3、计算机组成原理: 总线概述"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">3、计算机组成原理: 总线概述</div></div><div class="info-2"><div class="info-item-1">3、计算机组成原理: 总线概述引言在计算机组成原理的知识体系中，总线是连接计算机各个功能部件的关键纽带，如同城市里的交通网络，支撑着数据、指令与控制信号的高效传输。无论是初学者初识计算机内部架构，还是有经验的开发者深入优化系统性能，理解总线的工作机制、分类特性与标准规范，都有着至关重要的意义。 从第一台电子计算机 ENIAC 的庞杂布线，到现代智能手机芯片内部的纳米级总线，总线技术的演进直接推动了计算机性能的飞跃。ENIAC 没有真正意义上的总线，部件间通过数千根导线点对点连接，修改程序需重新布线，效率极低；而如今的超级计算机，通过高速总线将数万颗处理器、PB 级内存与海量存储设备连接，实现每秒亿亿次的运算能力。这种跨越背后，是总线从 “物理连线” 到 “智能交互系统” 的蜕变。 本系列将结合哈工大计算机组成原理课程内容，从基础概念到实际应用，从经典标准到前沿趋势，全方位剖析总线系统。通过字符图、案例分析、工程实践等多元形式，助力初学者构建完整知识框架，为资深从业者提供深度技术参考，最终让读者理解：总线不仅是 “连接线”，更是计算机系统协同运作的 “神经中枢”。 一、总线基础概念...</div></div></div></a><a class="pagination-related" href="/1-ji-suan-ji-zu-cheng-yuan-li-liao-jie-di-ceng-luo-ji/" title="1、计算机组成原理-了解底层逻辑"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">1、计算机组成原理-了解底层逻辑</div></div><div class="info-2"><div class="info-item-1">1、计算机组成原理-了解底层逻辑一、引言计算机组成原理，作为计算机专业基石课程，搭建起从硬件电路到软件运行的理解桥梁。初次接触其知识体系，恰似打开神秘黑箱，看清内部精密协作的齿轮，知晓程序如何在硬件舞台上 “翩翩起舞”，理解计算机系统如何高效运转。本文从程序执行流程、计算机硬件结构、指令系统、体系结构设计等维度，深入探寻计算机组成原理的奥秘，为后续深入学习筑牢根基。 二、程序执行：指令的 “生命旅程”（一）从高级语言到机器指令当我们在编程时写下z = x + y这样简洁的高级语言表达式，计算机无法直接理解。高级语言需经过编译或解释过程，转化为机器指令序列，这是计算机能识别并执行的 “母语”。机器指令由 0 和 1 组成的二进制代码构成，对应着计算机硬件可直接操作的基本动作。 （二）指令执行的 “三步走”程序执行核心流程可概括为取指令、分析指令（解码）、执行指令，循环往复直至程序结束，时钟信号如同精准的 “节拍器”，驱动每一步有序推进。  取指令：CPU 从存储器中指定位置（由程序计数器 PC 指向）读取指令。比如执行z = x + y，首先要获取LOAD X指令，此时存储器需准确...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/1-ji-suan-ji-zu-cheng-yuan-li-liao-jie-di-ceng-luo-ji/" title="1、计算机组成原理-了解底层逻辑"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-27</div><div class="info-item-2">1、计算机组成原理-了解底层逻辑</div></div><div class="info-2"><div class="info-item-1">1、计算机组成原理-了解底层逻辑一、引言计算机组成原理，作为计算机专业基石课程，搭建起从硬件电路到软件运行的理解桥梁。初次接触其知识体系，恰似打开神秘黑箱，看清内部精密协作的齿轮，知晓程序如何在硬件舞台上 “翩翩起舞”，理解计算机系统如何高效运转。本文从程序执行流程、计算机硬件结构、指令系统、体系结构设计等维度，深入探寻计算机组成原理的奥秘，为后续深入学习筑牢根基。 二、程序执行：指令的 “生命旅程”（一）从高级语言到机器指令当我们在编程时写下z = x + y这样简洁的高级语言表达式，计算机无法直接理解。高级语言需经过编译或解释过程，转化为机器指令序列，这是计算机能识别并执行的 “母语”。机器指令由 0 和 1 组成的二进制代码构成，对应着计算机硬件可直接操作的基本动作。 （二）指令执行的 “三步走”程序执行核心流程可概括为取指令、分析指令（解码）、执行指令，循环往复直至程序结束，时钟信号如同精准的 “节拍器”，驱动每一步有序推进。  取指令：CPU 从存储器中指定位置（由程序计数器 PC 指向）读取指令。比如执行z = x + y，首先要获取LOAD X指令，此时存储器需准确...</div></div></div></a><a class="pagination-related" href="/10-ji-suan-ji-zu-cheng-yuan-li-i-o-xi-tong-yu-shu-ju-chuan-shu-ji-zhi/" title="10、计算机组成原理: I&#x2F;O 系统与数据传输机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-26</div><div class="info-item-2">10、计算机组成原理: I&#x2F;O 系统与数据传输机制</div></div><div class="info-2"><div class="info-item-1">计算机组成原理之 I/O 系统与数据传输机制深度解析前言在计算机组成原理的知识体系中，输入输出（I/O）系统是连接计算机与外部世界的桥梁，其性能直接影响整个计算机系统的效率与实用性。从初学者的角度，理解 I/O 设备如何与 CPU、主存协作是构建计算机系统认知的关键；对于有经验的从业者，深入掌握 I/O 数据传输的底层机制则是优化系统性能、解决复杂工程问题的基石。 一、I/O 设备：计算机与外界的交互终端1.1 I/O 设备的分类与功能I/O 设备是计算机与用户、其他设备交互的媒介，可从多个维度分类：  人机交互设备：如键盘、鼠标、显示器、打印机等，是人与计算机直接交互的工具。 键盘：通过按键输入字符，核心是 “编码键盘法”，能识别按键并将其转换为 ASCII 码。 鼠标：分为机械式（依靠金属球和电位器检测位移）和光电式（通过光电转换器捕捉移动轨迹），是图形界面操作的核心输入设备。 显示器：实现字符显示（依赖字符发生器）、图形显示（主观图像绘制）、图像显示（客观图像还原），是最主要的输出设备之一。 打印机：击打式（如点阵打印机，逐字、逐行打印）和非击打式（如激光打印机逐页打印、喷...</div></div></div></a><a class="pagination-related" href="/4-ji-suan-ji-zu-cheng-yuan-li-tan-suo-zong-xian-yan-jin-guo-cheng/" title="4、计算机组成原理: 探索总线演进过程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-03</div><div class="info-item-2">4、计算机组成原理: 探索总线演进过程</div></div><div class="info-2"><div class="info-item-1">4、计算机组成原理: 探索总线演进过程一、引言在计算机系统的庞大体系中，总线如同人体的 “神经网络”，承担着各部件间数据、地址与控制信号传输的关键任务。从早期结构简单的单总线，到如今复杂且高效的多层 PCI 总线，总线结构的每一次演进，都紧密契合着计算机性能提升与应用场景拓展的需求。本文将以时间为脉络，深度剖析各类总线结构的原理、特性及应用，带读者领略计算机总线技术发展的壮丽图景。 二、单总线结构：计算机总线的起点2.1 结构与组成单总线结构是计算机总线发展的初始形态，其核心是一条系统总线，将 CPU、主存以及各类 I/O 设备（通过 I/O 接口连接）全部连接起来。用文字符号构建的示意框图如下：CPU &lt;-&gt; 系统总线 &lt;-&gt; 主存系统总线 &lt;-&gt; I/O接口1 &lt;-&gt; I/O设备1系统总线 &lt;-&gt; I/O接口2 &lt;-&gt; I/O设备2...系统总线 &lt;-&gt; I/O接口n &lt;-&gt; I/O设备n 2.2 工作原理在单总线结构中，所有部件共享同一条系统总线。当 CPU 需要与主存交换数据时...</div></div></div></a><a class="pagination-related" href="/3-ji-suan-ji-zu-cheng-yuan-li-zong-xian-gai-shu/" title="3、计算机组成原理: 总线概述"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-01</div><div class="info-item-2">3、计算机组成原理: 总线概述</div></div><div class="info-2"><div class="info-item-1">3、计算机组成原理: 总线概述引言在计算机组成原理的知识体系中，总线是连接计算机各个功能部件的关键纽带，如同城市里的交通网络，支撑着数据、指令与控制信号的高效传输。无论是初学者初识计算机内部架构，还是有经验的开发者深入优化系统性能，理解总线的工作机制、分类特性与标准规范，都有着至关重要的意义。 从第一台电子计算机 ENIAC 的庞杂布线，到现代智能手机芯片内部的纳米级总线，总线技术的演进直接推动了计算机性能的飞跃。ENIAC 没有真正意义上的总线，部件间通过数千根导线点对点连接，修改程序需重新布线，效率极低；而如今的超级计算机，通过高速总线将数万颗处理器、PB 级内存与海量存储设备连接，实现每秒亿亿次的运算能力。这种跨越背后，是总线从 “物理连线” 到 “智能交互系统” 的蜕变。 本系列将结合哈工大计算机组成原理课程内容，从基础概念到实际应用，从经典标准到前沿趋势，全方位剖析总线系统。通过字符图、案例分析、工程实践等多元形式，助力初学者构建完整知识框架，为资深从业者提供深度技术参考，最终让读者理解：总线不仅是 “连接线”，更是计算机系统协同运作的 “神经中枢”。 一、总线基础概念...</div></div></div></a><a class="pagination-related" href="/5-ji-suan-ji-zu-cheng-yuan-li-cun-chu-qi-yuan-li-fen-xi/" title="5、计算机组成原理: 存储器原理分析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-04</div><div class="info-item-2">5、计算机组成原理: 存储器原理分析</div></div><div class="info-2"><div class="info-item-1">5、计算机组成原理: 存储器原理分析引言在计算机系统的复杂架构中，存储器扮演着极为关键的角色，它是数据与程序的 “栖息地”，支撑着计算机从简单的指令执行到复杂的多任务处理。深入探究存储器的分类、层次结构，不仅有助于理解计算机高效运行的底层逻辑，更能为硬件设计优化、软件性能调优筑牢理论根基。接下来，我们将全方位、深层次地剖析计算机存储器体系。 一、存储器分类全解（一）按存储介质分类存储介质作为存储器的 “物质基础”，直接决定了其存储原理与特性，主要有以下几类：  半导体存储器 技术基础：依托半导体器件构建存储单元，常见的有 TTL（晶体管 - 晶体管逻辑）和 MOS（金属 - 氧化物 - 半导体）技术。TTL 速度较快，但功耗高；MOS 功耗低、集成度高，是现代半导体存储器的主流技术。 易失性特质：所谓 “易失”，指的是一旦断电，存储的信息便会丢失。这是因为其存储依赖于半导体器件的电状态，断电后电状态无法维持。像计算机的内存（RAM），就多采用半导体存储，系统运行时临时数据存于此处，关机重启后需重新加载。   磁表面存储器 核心部件：由磁头和载磁体（如硬盘的盘片、磁带等）构成。磁头...</div></div></div></a><a class="pagination-related" href="/7-ji-suan-ji-zu-cheng-yuan-li-shen-ru-li-jie-gao-su-huan-chong-cun-chu-qi-cache/" title="7、计算机组成原理: 深入理解高速缓冲存储器（Cache)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-21</div><div class="info-item-2">7、计算机组成原理: 深入理解高速缓冲存储器（Cache)</div></div><div class="info-2"><div class="info-item-1">深入理解计算机高速缓冲存储器（Cache）前言：为什么需要 Cache？在计算机系统中，CPU 的速度与主存储器（DRAM）的速度之间存在着数量级的差距。这种差距导致 CPU 在等待主存数据时会出现大量的 “空等” 现象，严重制约了整个计算机系统的性能。为了解决这一问题，高速缓冲存储器（Cache）应运而生。 Cache 是一种速度极快、容量较小的存储器，位于 CPU 和主存之间。它利用程序访问的局部性原理（即程序在执行时，短期内会重复访问某些指令或数据），将 CPU 近期可能访问的指令和数据预先缓存起来，从而减少 CPU 对主存的直接访问，大幅提升系统性能。 一、Cache 概述1.1 问题的提出现代 CPU 的时钟频率已经达到 GHz 级别，而主存（DRAM）的访问速度通常在几十到几百个时钟周期之间。假设 CPU 需要从主存中读取一个数据，主存需要 100 个时钟周期才能返回数据，而在这 100 个时钟周期内，CPU 只能处于等待状态，这无疑是对计算资源的巨大浪费。 为了避免这种 “空等” 现象，我们需要在 CPU 和主存之间设置一个速度接近 CPU 的存储器，这就是 Cac...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">lvting.chi</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%9A%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">2、计算机组成原理：概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%BC%95%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">一、引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%95%B4%E4%BD%93%E8%AE%A4%E8%AF%86"><span class="toc-number">1.2.</span> <span class="toc-text">二、计算机系统整体认识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.1.</span> <span class="toc-text">（一）层次结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BB%84%E6%88%90"><span class="toc-number">1.2.2.</span> <span class="toc-text">（二）体系结构与组成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">2.2.1 计算机体系结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2.2.2 计算机组成</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%A1%AC%E4%BB%B6%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%8C%87%E6%A0%87"><span class="toc-number">1.3.</span> <span class="toc-text">三、硬件核心技术指标</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E6%9C%BA%E5%99%A8%E5%AD%97%E9%95%BF"><span class="toc-number">1.3.1.</span> <span class="toc-text">（一）机器字长</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E8%BF%90%E7%AE%97%E9%80%9F%E5%BA%A6"><span class="toc-number">1.3.2.</span> <span class="toc-text">（二）运算速度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E5%AD%98%E5%82%A8%E5%AE%B9%E9%87%8F"><span class="toc-number">1.3.3.</span> <span class="toc-text">（三）存储容量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E4%B8%BB%E5%AD%98%E5%AE%B9%E9%87%8F"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">3.3.1 主存容量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-%E8%BE%85%E5%AD%98%E5%AE%B9%E9%87%8F"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">3.3.2 辅存容量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E8%BF%90%E7%AE%97%E5%99%A8%E6%8E%A2%E7%A7%98"><span class="toc-number">1.4.</span> <span class="toc-text">四、运算器探秘</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90"><span class="toc-number">1.4.1.</span> <span class="toc-text">（一）基本组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E5%AE%9A%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97"><span class="toc-number">1.4.2.</span> <span class="toc-text">（二）定点数运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E5%AE%9A%E7%82%B9%E5%8A%A0%E6%B3%95%E4%B8%8E%E5%87%8F%E6%B3%95%E8%BF%90%E7%AE%97"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">4.2.1 定点加法与减法运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E5%AE%9A%E7%82%B9%E4%B9%98%E6%B3%95%E8%BF%90%E7%AE%97"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">4.2.2 定点乘法运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-%E5%AE%9A%E7%82%B9%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">4.2.3 定点除法运算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97"><span class="toc-number">1.4.3.</span> <span class="toc-text">（三）浮点数运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-%E5%AF%B9%E9%98%B6"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">4.3.1 对阶</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-%E5%B0%BE%E6%95%B0%E8%BF%90%E7%AE%97"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">4.3.2 尾数运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-3-%E8%A7%84%E6%A0%BC%E5%8C%96"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">4.3.3 规格化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-4-%E8%88%8D%E5%85%A5"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">4.3.4 舍入</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.5.</span> <span class="toc-text">五、存储器系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84-1"><span class="toc-number">1.5.1.</span> <span class="toc-text">（一）层次结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.5.2.</span> <span class="toc-text">（二）主存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1-%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8%EF%BC%88RAM%EF%BC%89"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">5.2.1 随机存取存储器（RAM）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2-%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8%EF%BC%88ROM%EF%BC%89"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">5.2.2 只读存储器（ROM）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E5%AD%98%E5%82%A8%E5%99%A8%E6%89%A9%E5%B1%95"><span class="toc-number">1.5.3.</span> <span class="toc-text">（三）存储器扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-%E4%BD%8D%E6%89%A9%E5%B1%95"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">5.3.1 位扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2-%E5%AD%97%E6%89%A9%E5%B1%95"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">5.3.2 字扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-3-%E5%AD%97%E4%BD%8D%E5%90%8C%E6%97%B6%E6%89%A9%E5%B1%95"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">5.3.3 字位同时扩展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.5.4.</span> <span class="toc-text">（四）高速缓冲存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-1-Cache-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">5.4.1 Cache 的工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-2-Cache-%E7%9A%84%E6%98%A0%E5%B0%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">5.4.2 Cache 的映射方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-3-Cache-%E7%9A%84%E6%9B%BF%E6%8D%A2%E7%AD%96%E7%95%A5"><span class="toc-number">1.5.4.3.</span> <span class="toc-text">5.4.3 Cache 的替换策略</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">1.6.</span> <span class="toc-text">六、控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90-1"><span class="toc-number">1.6.1.</span> <span class="toc-text">（一）基本组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F"><span class="toc-number">1.6.2.</span> <span class="toc-text">（二）指令周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1-%E5%8F%96%E6%8C%87%E5%91%A8%E6%9C%9F"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">6.2.1 取指周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2-%E9%97%B4%E5%9D%80%E5%91%A8%E6%9C%9F%EF%BC%88%E8%8B%A5%E9%9C%80%E8%A6%81%EF%BC%89"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">6.2.2 间址周期（若需要）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-3-%E6%89%A7%E8%A1%8C%E5%91%A8%E6%9C%9F"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">6.2.3 执行周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-4-%E4%B8%AD%E6%96%AD%E5%91%A8%E6%9C%9F%EF%BC%88%E8%8B%A5%E5%8F%91%E7%94%9F%E4%B8%AD%E6%96%AD%EF%BC%89"><span class="toc-number">1.6.2.4.</span> <span class="toc-text">6.2.4 中断周期（若发生中断）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">1.6.3.</span> <span class="toc-text">（三）控制方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-1-%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">6.3.1 同步控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-2-%E5%BC%82%E6%AD%A5%E6%8E%A7%E5%88%B6"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">6.3.2 异步控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-3-%E8%81%94%E5%90%88%E6%8E%A7%E5%88%B6"><span class="toc-number">1.6.3.3.</span> <span class="toc-text">6.3.3 联合控制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">1.6.4.</span> <span class="toc-text">（四）微程序控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-1-%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">6.4.1 微程序控制器的组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-2-%E5%BE%AE%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">6.4.2 微程序的执行过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-3-%E5%BE%AE%E6%8C%87%E4%BB%A4%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F"><span class="toc-number">1.6.4.3.</span> <span class="toc-text">6.4.3 微指令的编码方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.7.</span> <span class="toc-text">七、输入输出系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89I-O-%E8%AE%BE%E5%A4%87"><span class="toc-number">1.7.1.</span> <span class="toc-text">（一）I&#x2F;O 设备</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-1-%E8%BE%93%E5%85%A5%E8%AE%BE%E5%A4%87"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">7.1.1 输入设备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-2-%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">7.1.2 输出设备</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89I-O-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.7.2.</span> <span class="toc-text">（二）I&#x2F;O 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-1-I-O-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">7.2.1 I&#x2F;O 接口的功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-2-I-O-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">7.2.2 I&#x2F;O 接口的分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89I-O-%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.3.</span> <span class="toc-text">（三）I&#x2F;O 控制方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-1-%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">7.3.1 程序查询方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-2-%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">7.3.2 中断控制方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-3-%E7%9B%B4%E6%8E%A5%E5%AD%98%E5%82%A8%E5%99%A8%E8%AE%BF%E9%97%AE%EF%BC%88DMA%EF%BC%89%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.3.3.</span> <span class="toc-text">7.3.3 直接存储器访问（DMA）方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-4-%E9%80%9A%E9%81%93%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.3.4.</span> <span class="toc-text">7.3.4 通道方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E4%B8%8E%E5%8F%91%E5%B1%95"><span class="toc-number">1.8.</span> <span class="toc-text">八、系统性能与发展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7"><span class="toc-number">1.8.1.</span> <span class="toc-text">（一）性能评价</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-1-%E5%9F%BA%E5%87%86%E7%A8%8B%E5%BA%8F%E6%B3%95"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">8.1.1 基准程序法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-2-%E6%A8%A1%E5%9E%8B%E6%B3%95"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">8.1.2 模型法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%91%E5%B1%95%E8%B6%8B%E5%8A%BF"><span class="toc-number">1.8.2.</span> <span class="toc-text">（二）发展趋势</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-%E9%AB%98%E6%80%A7%E8%83%BD%E5%8C%96"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">8.2.1 高性能化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-2-%E5%BE%AE%E5%9E%8B%E5%8C%96%E4%B8%8E%E4%BE%BF%E6%90%BA%E5%8C%96"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">8.2.2 微型化与便携化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-3-%E7%BD%91%E7%BB%9C%E5%8C%96%E4%B8%8E%E6%99%BA%E8%83%BD%E5%8C%96"><span class="toc-number">1.8.2.3.</span> <span class="toc-text">8.2.3 网络化与智能化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-4-%E8%8A%82%E8%83%BD"><span class="toc-number">1.8.2.4.</span> <span class="toc-text">8.2.4 节能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-number">1.9.</span> <span class="toc-text">结语</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/10-ji-suan-ji-zu-cheng-yuan-li-i-o-xi-tong-yu-shu-ju-chuan-shu-ji-zhi/" title="10、计算机组成原理: I/O 系统与数据传输机制">10、计算机组成原理: I/O 系统与数据传输机制</a><time datetime="2025-09-26T13:12:57.000Z" title="发表于 2025-09-26 21:12:57">2025-09-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/9-ji-suan-ji-zu-cheng-yuan-li-i-o-xi-tong/" title="9、计算机组成原理: I/O系统">9、计算机组成原理: I/O系统</a><time datetime="2025-09-25T13:56:34.000Z" title="发表于 2025-09-25 21:56:34">2025-09-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/8-ji-suan-ji-zu-cheng-yuan-li-fu-zhu-cun-chu-qi-shen-du-jie-xi/" title="8、计算机组成原理: 辅助存储器深度解析">8、计算机组成原理: 辅助存储器深度解析</a><time datetime="2025-09-24T13:23:41.000Z" title="发表于 2025-09-24 21:23:41">2025-09-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/7-ji-suan-ji-zu-cheng-yuan-li-shen-ru-li-jie-gao-su-huan-chong-cun-chu-qi-cache/" title="7、计算机组成原理: 深入理解高速缓冲存储器（Cache)">7、计算机组成原理: 深入理解高速缓冲存储器（Cache)</a><time datetime="2025-09-21T13:56:21.000Z" title="发表于 2025-09-21 21:56:21">2025-09-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/6-ji-suan-ji-zu-cheng-yuan-li-shen-ru-xue-xi-cun-chu-xi-tong/" title="6、计算机组成原理: 深入学习存储系统">6、计算机组成原理: 深入学习存储系统</a><time datetime="2025-09-04T13:40:00.000Z" title="发表于 2025-09-04 21:40:00">2025-09-04</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By lvting.chi</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>